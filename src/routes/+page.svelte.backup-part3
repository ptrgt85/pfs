<script lang="ts">
  import { onMount } from 'svelte';
  import { goto } from '$app/navigation';
  
  // Component imports
  import AuthHeader from '$lib/components/AuthHeader.svelte';
  import ActivityLogPanel from '$lib/components/ActivityLogPanel.svelte';
  import NewCompanyModal from '$lib/components/NewCompanyModal.svelte';
  import UserManagementModal from '$lib/components/UserManagementModal.svelte';
  import SummaryBar from '$lib/components/SummaryBar.svelte';
  import PropertiesPanel from '$lib/components/PropertiesPanel.svelte';
  import DocumentPanel from '$lib/components/DocumentPanel.svelte';
  import PricingPanel from '$lib/components/PricingPanel.svelte';
  import LandBudgetPanel from '$lib/components/LandBudgetPanel.svelte';
  import ForecastPanel from '$lib/components/ForecastPanel.svelte';
  import PricingReviewModal from '$lib/components/PricingReviewModal.svelte';
  import FieldsManagerModal from '$lib/components/FieldsManagerModal.svelte';
  import ExtractionModals from '$lib/components/ExtractionModals.svelte';
  
  // ===== AUTHENTICATION STATE =====
  interface User {
    id: number;
    email: string;
    name: string;
    isMaster: boolean;
    theme?: string;
    access?: Array<{
      entityType: string;
      entityId: number;
      roleName: string;
      canView: number;
      canEdit: number;
      canDelete: number;
      canInvite: number;
      canManageRoles: number;
    }>;
  }
  
  let currentUser: User | null = null;
  let authLoading = true;
  
  // Modal state
  let showUserManagement = false;
  let showNewCompanyModal = false;
  let logPanelCollapsed = false;
  
  // Check if current user is admin (has canInvite permission)
  $: isAdmin = currentUser?.access?.some(a => a.canInvite === 1) || false;
  $: canManageUsers = currentUser?.isMaster || isAdmin;
  
  // Get user's primary role info
  $: userPrimaryRole = currentUser?.access?.[0]?.roleName || null;
  $: userCanEdit = currentUser?.isMaster || currentUser?.access?.some(a => a.canEdit === 1) || false;
  $: userCanDelete = currentUser?.isMaster || currentUser?.access?.some(a => a.canDelete === 1) || false;
  $: userCanView = currentUser?.isMaster || currentUser?.access?.some(a => a.canView === 1) || false;
  
  async function checkAuth() {
    try {
      console.log('[DEBUG] checkAuth: fetching /api/auth/me...');
      const res = await fetch('/api/auth/me');
      console.log('[DEBUG] checkAuth: response status', res.status);
      const data = await res.json();
      console.log('[DEBUG] checkAuth: user found?', !!data.user);
      currentUser = data.user;
      if (!currentUser) {
        console.log('[DEBUG] checkAuth: no user, redirecting to /login');
        goto('/login');
      }
    } catch (e) {
      console.error('[DEBUG] checkAuth error:', e);
      goto('/login');
    } finally {
      console.log('[DEBUG] checkAuth: setting authLoading = false');
      authLoading = false;
    }
  }
  
  async function logout() {
    await fetch('/api/auth/logout', { method: 'POST' });
    currentUser = null;
    goto('/login');
  }
  
  // Check permissions for current node
  function hasPermission(permission: 'canView' | 'canEdit' | 'canDelete' | 'canInvite' | 'canManageRoles'): boolean {
    if (!currentUser) return false;
    if (currentUser.isMaster) return true;
    if (!selectedNode || !currentUser.access) return false;
    
    // Check access for this entity or any parent
    const access = currentUser.access.find(a => 
      a.entityType === selectedNode!.type && a.entityId === selectedNode!.id
    );
    
    return access ? access[permission] === 1 : false;
  }
  
  interface TreeNode {
    id: number;
    name: string;
    type: string;
    parentId: number | null;
    children?: TreeNode[];
    expanded?: boolean;
    loading?: boolean;
  }
  
  let tree: TreeNode[] = [];
  let selectedNode: TreeNode | null = null;
  let tableData: any[] = [];
  let loading = false;
  let activityLog: Array<{time: string, message: string, type: 'success' | 'error' | 'loading' | 'info' | 'warning'}> = [];
  let editingId: number | null = null;
  let editValues: Record<string, string> = {};
  let isAdding = false;
  let newRowValues: Record<string, string> = {};
  
  // Loading states for save operations
  let savingRow = false;
  let savingAdd = false;
  let savingProperty = false;
  let savingExtraction = false;
  let savingDates = false;
  let deletingRow: number | null = null;
  let sortColumn: string = '';
  let sortDirection: 'asc' | 'desc' = 'asc';
  let entityDetails: any = null;
  let editingProperty: string | null = null;
  let propertyEditValue: string = '';
  let hierarchyPath: Array<{type: string, name: string}> = [];
  let documents: any[] = [];
  let extractingDocId: number | null = null; // Track which specific document is being extracted
  let extractionProgress = { current: 0, total: 0, status: '' }; // Progress tracking
  let extractionResult: any = null;
  let showExtractionModal = false;
  let previewDocument: any = null;
  
  // Continuation extraction state
  let showContinueModal = false;
  let continuationInfo: { docId: number, remainingStages: string[], estimatedLots: number, existingData: any } | null = null;
  
  // Document type options (used by DocumentPanel)
  const documentTypeOptions = [
    { id: 'permit_plan', name: 'Permit Plan', desc: 'Initial planning document with stages/lots' },
    { id: 'plan_subdivision', name: 'Plan of Subdivision', desc: 'Registered plan with lot details' },
    { id: 'other', name: 'Other', desc: 'Supporting documents' }
  ];
  
  // Extraction hints - user-provided context to assist AI
  let extractionHints = '';
  let showHintsInput = false;
  let showPreExtractionModal = false;
  let pendingExtractionDocId: number | null = null;
  
  // Bulk edit state
  let selectedRows: Set<number> = new Set();
  let bulkEditField = '';
  let bulkEditValue = '';
  let showBulkEdit = false;
  
  // Inline document viewer state
  let inlineDocument: any = null;
  let inlineZoom = 1;
  let inlineViewerHeight = 250;
  let pdfPageNumber = 1;
  let analyzingPage = false;
  
  // Verification/correction state
  let verificationResult: any = null;
  let showVerificationModal = false;
  
  // POS Analysis state
  let showPosAnalysisModal = false;
  let posAnalysisResult: any = null;
  let analyzingPos = false;
  let posAnalysisFilter: 'all' | 'variance' | 'easements' | 'match' = 'all';
  let expandedLots: Set<string> = new Set();
  
  // AI Model selection
  let selectedModel: 'gemini' | 'grok' | 'openai' = 'gemini';
  const modelOptions = [
    { id: 'gemini', name: 'Gemini 3 Flash', desc: 'Google AI - Best for complex plans & OCR (Free tier)' },
    { id: 'openai', name: 'GPT-5 Mini (OpenAI)', desc: 'OpenAI vision model - Fast & affordable' },
    { id: 'grok', name: 'Grok 2 Vision (xAI)', desc: 'xAI vision model' }
  ];
  
  // AI Learning - track user corrections for pattern recognition
  let correctionHistory: { 
    lotNumber: string; 
    field: string; 
    oldValue: string; 
    newValue: string;
    timestamp: Date;
  }[] = [];
  
  // Screen capture state
  let capturedImage: string | null = null;
  let isCapturing = false;
  
  // Calibration state - for verifying AI accuracy before showing results
  let showCalibrationModal = false;
  let calibrationSamples: {
    lotNumber: string;
    area: string;
    frontage: string;
    depth: string;
    streetName: string;
    userArea: string;
    userFrontage: string;
    userDepth: string;
    userStreetName: string;
    confirmed: boolean;
  }[] = [];
  let calibrationDocId: number | null = null;
  let calibrationPageNum: number = 1;
  let pendingFullResults: any = null;
  let isCalibrating = false;
  
  // Visual box calibration state
  let showBoxCalibration = false;
  let boxCalibrationImage: string | null = null;
  let boxCalibrationLots: {
    lotNumber: string;
    fields: {
      name: string;
      aiValue: string;
      userValue: string;
      box: { x: number; y: number; width: number; height: number } | null;
      confirmed: boolean;
    }[];
  }[] = [];
  let currentLotIndex = 0;
  let currentFieldIndex = 0;
  let isDrawingBox = false;
  let drawStartPos = { x: 0, y: 0 };
  let currentBox: { x: number; y: number; width: number; height: number } | null = null;
  let boxCanvasRef: HTMLCanvasElement | null = null;
  let boxImageRef: HTMLImageElement | null = null;
  
  // Collapsible sections
  let showProperties = true;
  let showSummary = true;
  let showStageTable = true;
  
  // ===== USER PREFERENCES (DB-backed) =====
  let nodePreferences: Record<string, Record<string, string>> = {}; // Cache: "type:id" -> { prefKey: prefValue }
  
  async function loadNodePreferences(entityType: string, entityId: number): Promise<Record<string, string>> {
    const key = `${entityType}:${entityId}`;
    if (nodePreferences[key]) return nodePreferences[key];
    
    try {
      const res = await fetch(`/api/preferences?entityType=${entityType}&entityId=${entityId}`);
      const prefs = await res.json();
      nodePreferences[key] = prefs;
      return prefs;
    } catch (e) {
      console.warn('Failed to load preferences:', e);
      return {};
    }
  }
  
  async function saveNodePreference(entityType: string, entityId: number, prefKey: string, prefValue: boolean | string) {
    const key = `${entityType}:${entityId}`;
    // Update cache
    if (!nodePreferences[key]) nodePreferences[key] = {};
    nodePreferences[key][prefKey] = String(prefValue);
    
    try {
      await fetch('/api/preferences', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ entityType, entityId, prefKey, prefValue: String(prefValue) })
      });
    } catch (e) {
      console.warn('Failed to save preference:', e);
    }
  }
  
  function getNodePreference(entityType: string, entityId: number, prefKey: string, defaultValue: boolean = false): boolean {
    const key = `${entityType}:${entityId}`;
    const prefs = nodePreferences[key];
    if (!prefs || prefs[prefKey] === undefined) return defaultValue;
    return prefs[prefKey] === 'true';
  }
  
  // Custom fields state
  let customFields: { id: number; entityType: string; fieldKey: string; fieldLabel: string; fieldType: string; fieldFormat?: string; isActive: number }[] = [];
  let hiddenFields: Set<string> = new Set(); // Fields user has hidden from view
  let showFieldsManager = false;
  
  // Field ordering state
  let fieldOrder: string[] = []; // Order of field keys
  let draggingField: string | null = null;
  
  // Column resize state
  let columnWidths: Record<string, number> = {};
  let resizingColumn: string | null = null;
  let resizeStartX = 0;
  let resizeStartWidth = 0;
  
  // Status field options with colors
  const statusOptions = [
    { value: 'masterplan', label: 'Masterplan', color: '#7aa2f7', bg: 'rgba(122, 162, 247, 0.2)' },
    { value: 'on_market', label: 'On Market', color: '#9ece6a', bg: 'rgba(158, 206, 106, 0.2)' },
    { value: 'hold', label: 'Hold', color: '#e0af68', bg: 'rgba(224, 175, 104, 0.2)' },
    { value: 'exchanged', label: 'Exchanged', color: '#bb9af7', bg: 'rgba(187, 154, 247, 0.2)' },
    { value: 'settled', label: 'Settled', color: '#73daca', bg: 'rgba(115, 218, 202, 0.2)' },
    { value: 'cancelled', label: 'Cancelled', color: '#f7768e', bg: 'rgba(247, 118, 142, 0.2)' }
  ];
  
  // Number format options
  const numberFormatOptions = [
    { value: '', label: 'Plain' },
    { value: '$', label: '$ (Currency)' },
    { value: 'sqm', label: 'sqm (Square Meters)' },
    { value: 'm', label: 'm (Meters)' },
    { value: 'custom', label: 'Custom' }
  ];
  
  // Common number presets
  const numberPresets = [
    { value: 100000, label: '100K' },
    { value: 250000, label: '250K' },
    { value: 500000, label: '500K' },
    { value: 750000, label: '750K' },
    { value: 1000000, label: '1M' },
    { value: 2000000, label: '2M' },
    { value: 5000000, label: '5M' }
  ];
  
  // Pricing state for Project Groups (shared with PricingPanel via bind)
  let pricingProducts: {
    id?: number;
    productName: string;
    frontage: number;
    depth: number;
    baseArea: number;
    basePrice: number;
    pricePerSqm: number;
    balanceRate: number;
  }[] = [];
  
  // Standard product types (sorted by area descending)
  const defaultProducts = [
    { frontage: 20, depth: 36, basePrice: 0 },
    { frontage: 20, depth: 32, basePrice: 0 },
    { frontage: 20, depth: 28, basePrice: 0 },
    { frontage: 18, depth: 36, basePrice: 0 },
    { frontage: 18, depth: 32, basePrice: 0 },
    { frontage: 16, depth: 36, basePrice: 0 },
    { frontage: 18, depth: 28, basePrice: 0 },
    { frontage: 16, depth: 32, basePrice: 0 },
    { frontage: 14, depth: 36, basePrice: 0 },
    { frontage: 16, depth: 28, basePrice: 0 },
    { frontage: 14, depth: 32, basePrice: 0 },
    { frontage: 16, depth: 25, basePrice: 0 },
    { frontage: 14, depth: 28, basePrice: 0 },
    { frontage: 12.5, depth: 32, basePrice: 0 },
    { frontage: 14, depth: 25, basePrice: 0 },
    { frontage: 12.5, depth: 28, basePrice: 0 },
    { frontage: 16, depth: 21, basePrice: 0 },
    { frontage: 10.5, depth: 32, basePrice: 0 },
    { frontage: 12.5, depth: 25, basePrice: 0 },
    { frontage: 14, depth: 21, basePrice: 0 },
    { frontage: 10.5, depth: 28, basePrice: 0 },
    { frontage: 13, depth: 21, basePrice: 0 },
    { frontage: 12.5, depth: 21, basePrice: 0 },
    { frontage: 10.5, depth: 25, basePrice: 0 },
    { frontage: 16, depth: 16, basePrice: 0 },
    { frontage: 8.5, depth: 28, basePrice: 0 },
    { frontage: 10.5, depth: 21, basePrice: 0 },
    { frontage: 8.5, depth: 25, basePrice: 0 },
    { frontage: 7.5, depth: 28, basePrice: 0 },
    { frontage: 5.1, depth: 28, basePrice: 0 },
    { frontage: 6.75, depth: 21, basePrice: 0 }
  ];
  
  async function loadPricing(projectId: number) {
    try {
      console.log('Loading pricing for projectId:', projectId);
      const res = await fetch(`/api/pricing?projectId=${projectId}`);
      const data = await res.json();
      console.log('Pricing API response:', data);
      if (data.length > 0) {
        pricingProducts = data.map((p: any) => ({
          id: p.id,
          productName: p.productName,
          frontage: parseFloat(p.frontage),
          depth: parseFloat(p.depth),
          baseArea: parseFloat(p.baseArea),
          basePrice: parseFloat(p.basePrice),
          pricePerSqm: parseFloat(p.pricePerSqm),
          balanceRate: parseFloat(p.balanceRate) || 50
        }));
        console.log('Loaded pricing products:', pricingProducts.map(p => ({ name: p.productName, basePrice: p.basePrice })));
      } else {
        // Initialize with default products (no prices set)
        pricingProducts = defaultProducts.map(p => ({
          productName: `${p.frontage}x${p.depth}`,
          frontage: p.frontage,
          depth: p.depth,
          baseArea: p.frontage * p.depth,
          basePrice: p.basePrice,
          pricePerSqm: 0,
          balanceRate: 50
        }));
        console.log('No pricing found, using defaults');
      }
    } catch (e) {
      console.error('Failed to load pricing:', e);
    }
  }
  
  function calculateLotPrice(lot: any): { basePrice: number; balancePrice: number; totalPrice: number; matchedProduct: string; pricePerSqm: number } | null {
    if (!lot.frontage || !lot.depth || pricingProducts.length === 0) return null;
    
    const lotFrontage = parseFloat(lot.frontage);
    const lotDepth = parseFloat(lot.depth);
    const lotArea = parseFloat(lot.area) || lotFrontage * lotDepth;
    
    if (lotFrontage <= 0 || lotDepth <= 0) return null;
    
    // Filter products with prices set
    const pricedProducts = pricingProducts.filter(p => p.basePrice > 0);
    if (pricedProducts.length === 0) return null;
    
    // Best practice: Find closest frontage WITHOUT going over lot frontage
    // Then find closest depth WITHOUT going over lot depth
    let bestMatch: typeof pricedProducts[0] | null = null;
    let bestScore = -Infinity;
    
    for (const product of pricedProducts) {
      // Prefer products with frontage <= lot frontage
      const frontageOK = product.frontage <= lotFrontage + 0.5;
      const depthOK = product.depth <= lotDepth + 0.5;
      
      if (frontageOK) {
        // Score: prefer closest frontage without going over (higher = better)
        const frontageScore = lotFrontage - product.frontage;
        const depthScore = depthOK ? (lotDepth - product.depth) : -50;
        
        // Combined score: prioritize frontage match, then depth
        const score = 100 - frontageScore * 10 - Math.abs(depthScore);
        
        if (score > bestScore) {
          bestScore = score;
          bestMatch = product;
        }
      }
    }
    
    // If no product fits (lot smaller than all products), use smallest product
    if (!bestMatch) {
      bestMatch = pricedProducts.reduce((min, p) => p.baseArea < min.baseArea ? p : min, pricedProducts[0]);
    }
    
    const basePrice = bestMatch.basePrice;
    const baseArea = bestMatch.baseArea;
    const balanceArea = Math.max(0, lotArea - baseArea);
    const balanceRate = bestMatch.balanceRate / 100;
    const balancePrice = balanceArea * bestMatch.pricePerSqm * balanceRate;
    const totalPrice = basePrice + balancePrice;
    
    return {
      basePrice,
      balancePrice,
      totalPrice,
      matchedProduct: bestMatch.productName || `${bestMatch.frontage}x${bestMatch.depth}`,
      pricePerSqm: Math.round(totalPrice / lotArea)
    };
  }
  
  // Apply pricing to all Masterplan status lots
  async function applyPricingToMasterplanLots() {
    if (!selectedNode || selectedNode.type !== 'stage') {
      log('Select a stage to apply pricing', 'error');
      return;
    }
    
    const masterplanLots = tableData.filter(lot => lot.status?.toLowerCase() === 'masterplan');
    if (masterplanLots.length === 0) {
      log('No lots with Masterplan status found', 'warning');
      return;
    }
    
    if (pricingProducts.length === 0 || !pricingProducts.some(p => p.basePrice > 0)) {
      log('Set up pricing products first', 'error');
      return;
    }
    
    let updated = 0;
    for (const lot of masterplanLots) {
      const pricing = calculateLotPrice(lot);
      if (pricing) {
        try {
          await fetch(`/api/lots/${lot.id}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              price: pricing.totalPrice,
              pricePerSqm: pricing.pricePerSqm
            })
          });
          updated++;
        } catch (e) {
          console.error('Failed to update lot pricing:', e);
        }
      }
    }
    
    log(`Applied pricing to ${updated} Masterplan lots`, 'success');
    await reloadTableData();
  }
  
  // Accept indicative price for a single lot
  async function acceptIndicativePrice(lot: any, price: number, pricePerSqm: number) {
    try {
      const res = await fetch(`/api/lots/${lot.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ price, pricePerSqm })
      });
      if (res.ok) {
        lot.price = price;
        lot.pricePerSqm = pricePerSqm;
        tableData = [...tableData];
        log(`Accepted price $${price.toLocaleString()} for Lot ${lot.lotNumber || lot.name}`, 'success');
      }
    } catch (e) {
      log('Failed to save price', 'error');
    }
  }
  
  // Stage-level pricing review state
  let showPricingReview = false;
  let stagePriceEdits: Map<number, number> = new Map();
  
  // Stage table tabs
  let stageTableTab: 'main' | 'dates' | 'pricing' = 'main';
  
  // ===== RESPONSIVE UI STATE =====
  let treeNavCollapsed = false;
  
  // Tab edit modes
  let datesTabEditMode = false;
  let pricingTabEditMode = false;
  let datesTabEdits: Map<number, Record<string, string>> = new Map();
  let pricingTabEdits: Map<number, Record<string, string>> = new Map();
  
  // Date status types: 'forecast' (future), 'actual' (confirmed past), 'pending' (past but unconfirmed)
  type DateStatus = 'forecast' | 'actual' | 'pending' | 'none';
  
  function getDateStatus(dateStr: string | null | undefined, isActual: boolean | number | undefined): DateStatus {
    if (!dateStr) return 'none';
    const date = new Date(dateStr);
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    if (date > today) {
      return 'forecast'; // Future date
    } else if (isActual) {
      return 'actual'; // Past date, confirmed as actual
    } else {
      return 'pending'; // Past date, not confirmed - needs attention
    }
  }
  
  // Get status indicator styles
  const dateStatusStyles: Record<DateStatus, { color: string; bg: string; border: string; label: string; title: string }> = {
    forecast: { color: '#e0af68', bg: 'rgba(224, 175, 104, 0.15)', border: '#e0af68', label: 'F', title: 'Forecast - Future date' },
    actual: { color: '#22c55e', bg: 'rgba(34, 197, 94, 0.2)', border: '#22c55e', label: 'A', title: 'Actual - Confirmed' },
    pending: { color: '#f7768e', bg: 'rgba(247, 118, 142, 0.15)', border: '#f7768e', label: 'P', title: 'Pending - Needs confirmation' },
    none: { color: '#565f89', bg: 'transparent', border: 'transparent', label: '', title: '' }
  };
  
  // Toggle actual confirmation for a lot date field
  async function toggleLotDateActual(lotId: number, dateField: string, currentCustomData: any) {
    const actualField = `${dateField}_actual`;
    const currentActual = currentCustomData[actualField] || false;
    const updatedCustomData = { ...currentCustomData, [actualField]: !currentActual };
    
    try {
      const res = await fetch('/api/lots', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id: lotId, customData: JSON.stringify(updatedCustomData) })
      });
      if (res.ok) {
        // Update local tableData
        const lotIndex = tableData.findIndex(l => l.id === lotId);
        if (lotIndex >= 0) {
          tableData[lotIndex].customData = updatedCustomData;
          tableData = [...tableData];
        }
        log(`Date ${!currentActual ? 'confirmed as actual' : 'reverted to pending'}`, 'success');
      }
    } catch (error) {
      log('Failed to update date status', 'error');
    }
  }
  
  // Toggle actual confirmation for a stage date field
  async function toggleStageDateActual(stageId: number, dateField: 'registrationDate' | 'settlementDate', currentActual: boolean) {
    const actualField = `${dateField}Actual`;
    
    try {
      const res = await fetch('/api/stages', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id: stageId, [actualField]: !currentActual })
      });
      if (res.ok) {
        // Update entityDetails
        entityDetails = { ...entityDetails, [actualField]: !currentActual ? 1 : 0 };
        log(`Stage date ${!currentActual ? 'confirmed as actual' : 'reverted to pending'}`, 'success');
      }
    } catch (error) {
      log('Failed to update stage date status', 'error');
    }
  }
  
  // Start editing dates tab
  function startDatesTabEdit() {
    datesTabEditMode = true;
    datesTabEdits = new Map();
    tableData.forEach(row => {
      const customData = row.customData ? (typeof row.customData === 'string' ? JSON.parse(row.customData) : row.customData) : {};
      datesTabEdits.set(row.id, {
        on_market_date: customData.on_market_date || '',
        sold_date: customData.sold_date || '',
        exchange_date: customData.exchange_date || '',
        settled_date: customData.settled_date || '',
        cancelled_date: customData.cancelled_date || ''
      });
    });
    datesTabEdits = datesTabEdits;
    log('Editing Key Dates - Save when ready', 'info');
  }
  
  // Start editing pricing tab
  function startPricingTabEdit() {
    pricingTabEditMode = true;
    pricingTabEdits = new Map();
    tableData.forEach(row => {
      const customData = row.customData ? (typeof row.customData === 'string' ? JSON.parse(row.customData) : row.customData) : {};
      pricingTabEdits.set(row.id, {
        deposit_amount: customData.deposit_amount || '',
        deposit_date: customData.deposit_date || '',
        rebates: customData.rebates || '',
        discounts: customData.discounts || '',
        price_adjustments: customData.price_adjustments || ''
      });
    });
    pricingTabEdits = pricingTabEdits;
    log('Editing Pricing Details - Save when ready', 'info');
  }
  
  // Cancel tab edits
  function cancelDatesTabEdit() {
    datesTabEditMode = false;
    datesTabEdits = new Map();
    log('Dates editing cancelled', 'info');
  }
  
  function cancelPricingTabEdit() {
    pricingTabEditMode = false;
    pricingTabEdits = new Map();
    log('Pricing editing cancelled', 'info');
  }
  
  // Save dates tab edits
  async function saveDatesTabEdits() {
    let saved = 0;
    let failed = 0;
    
    for (const [lotId, edits] of datesTabEdits) {
      const lot = tableData.find(l => l.id === lotId);
      if (!lot) continue;
      
      try {
        let customData: Record<string, any> = {};
        if (lot.customData) {
          customData = typeof lot.customData === 'string' ? JSON.parse(lot.customData) : { ...lot.customData };
        }
        
        // For each date field, check if the value changed and set the _manual flag
        const dateFields = ['on_market_date', 'sold_date', 'exchange_date', 'settled_date', 'cancelled_date'];
        for (const field of dateFields) {
          const oldValue = customData[field] || '';
          const newValue = edits[field] || '';
          if (newValue && newValue !== oldValue) {
            // User manually set/changed this date - mark as manual
            customData[`${field}_manual`] = true;
          } else if (!newValue && oldValue) {
            // User cleared this date - remove manual flag
            delete customData[`${field}_manual`];
          }
        }
        
        Object.assign(customData, edits);
        
        const res = await fetch('/api/lots', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id: lotId, customData: JSON.stringify(customData) })
        });
        
        if (res.ok) {
          lot.customData = JSON.stringify(customData);
          saved++;
        } else {
          failed++;
        }
      } catch (e) {
        failed++;
      }
    }
    
    tableData = [...tableData];
    datesTabEditMode = false;
    datesTabEdits = new Map();
    
    if (failed === 0) {
      log(`Saved dates for ${saved} lots`, 'success');
    } else {
      log(`Saved ${saved} lots, ${failed} failed`, 'warning');
    }
  }
  
  // Save pricing tab edits
  async function savePricingTabEdits() {
    let saved = 0;
    let failed = 0;
    
    for (const [lotId, edits] of pricingTabEdits) {
      const lot = tableData.find(l => l.id === lotId);
      if (!lot) continue;
      
      try {
        let customData: Record<string, any> = {};
        if (lot.customData) {
          customData = typeof lot.customData === 'string' ? JSON.parse(lot.customData) : { ...lot.customData };
        }
        
        Object.assign(customData, edits);
        
        const res = await fetch('/api/lots', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id: lotId, customData: JSON.stringify(customData) })
        });
        
        if (res.ok) {
          lot.customData = JSON.stringify(customData);
          saved++;
        } else {
          failed++;
        }
      } catch (e) {
        failed++;
      }
    }
    
    tableData = [...tableData];
    pricingTabEditMode = false;
    pricingTabEdits = new Map();
    
    if (failed === 0) {
      log(`Saved pricing details for ${saved} lots`, 'success');
    } else {
      log(`Saved ${saved} lots, ${failed} failed`, 'warning');
    }
  }
  
  // Inline price editing mode for table view
  let inlinePriceEditMode = false;
  let inlinePriceEdits: Map<number, number> = new Map(); // lotId -> price
  let savingAllPrices = false;
  
  // Start inline price editing mode
  function startInlinePriceEdit() {
    if (!selectedNode || selectedNode.type !== 'stage') return;
    
    inlinePriceEdits = new Map();
    
    // Initialize with current prices from database
    for (const lot of tableData) {
      const currentPrice = parseFloat(lot.price) || 0;
      // Always start with the current saved price
      inlinePriceEdits.set(lot.id, currentPrice);
    }
    
    inlinePriceEdits = inlinePriceEdits;
    inlinePriceEditMode = true;
    log('Editing prices for all lots - Save All when ready', 'info');
  }
  
  // Update inline price for a lot
  function updateInlinePrice(lotId: number, price: number) {
    inlinePriceEdits.set(lotId, price);
    inlinePriceEdits = inlinePriceEdits;
  }
  
  // Use indicative price for a lot
  function useIndicativePriceInline(lotId: number) {
    const lot = tableData.find(l => l.id === lotId);
    if (!lot) return;
    const indicative = calculateLotPrice(lot);
    if (indicative) {
      inlinePriceEdits.set(lotId, indicative.totalPrice);
      inlinePriceEdits = inlinePriceEdits;
      // Log price calculation breakdown for user review
      log(`Lot ${lot.lotNumber || lot.id}: Base ${indicative.matchedProduct} = $${indicative.basePrice.toLocaleString()} + Balance $${indicative.balancePrice.toLocaleString()} = $${indicative.totalPrice.toLocaleString()} ($${indicative.pricePerSqm}/mÂ²)`, 'info');
    }
  }
  
  // Apply all suggested prices at once
  function applyAllSuggestedPrices() {
    let appliedCount = 0;
    for (const lot of tableData) {
      const indicative = calculateLotPrice(lot);
      if (indicative) {
        inlinePriceEdits.set(lot.id, indicative.totalPrice);
        appliedCount++;
      }
    }
    inlinePriceEdits = inlinePriceEdits;
    log(`Applied suggested pricing to ${appliedCount} lots`, 'success');
  }
  
  // Cancel inline price editing
  function cancelInlinePriceEdit() {
    inlinePriceEditMode = false;
    inlinePriceEdits = new Map();
    log('Price editing cancelled', 'info');
  }
  
  // Save all inline price edits
  async function saveAllInlinePrices() {
    if (!selectedNode || selectedNode.type !== 'stage') return;
    
    const updates: { lotId: number; price: number; pricePerSqm: number }[] = [];
    
    inlinePriceEdits.forEach((price, lotId) => {
      const lot = tableData.find(l => l.id === lotId);
      if (!lot) return;
      const originalPrice = parseFloat(lot.price) || 0;
      if (price !== originalPrice && price > 0) {
        const area = parseFloat(lot.area) || (parseFloat(lot.frontage) * parseFloat(lot.depth)) || 1;
        updates.push({ lotId, price, pricePerSqm: Math.round(price / area) });
      }
    });
    
    if (updates.length === 0) {
      log('No price changes to save', 'warning');
      return;
    }
    
    savingAllPrices = true;
    let saved = 0;
    let failed = 0;
    
    for (const update of updates) {
      try {
        const res = await fetch(`/api/lots/${update.lotId}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ price: update.price, pricePerSqm: update.pricePerSqm })
        });
        if (res.ok) {
          saved++;
          const lot = tableData.find(l => l.id === update.lotId);
          if (lot) {
            lot.price = update.price;
            lot.pricePerSqm = update.pricePerSqm;
          }
        } else {
          failed++;
        }
      } catch (e) {
        failed++;
      }
    }
    
    tableData = [...tableData];
    savingAllPrices = false;
    inlinePriceEditMode = false;
    inlinePriceEdits = new Map();
    
    if (failed === 0) {
      log(`Saved pricing for ${saved} lots`, 'success');
    } else {
      log(`Saved ${saved} lots, ${failed} failed`, 'warning');
    }
  }
  
  // Update custom field in lot's customData
  async function updateCustomField(lotId: number, fieldKey: string, value: string) {
    const lot = tableData.find(l => l.id === lotId);
    if (!lot) return;
    
    try {
      // Parse existing customData or create new object
      let customData: Record<string, any> = {};
      if (lot.customData) {
        customData = typeof lot.customData === 'string' ? JSON.parse(lot.customData) : { ...lot.customData };
      }
      
      // Update the field
      customData[fieldKey] = value;
      
      // Save to database
      const res = await fetch('/api/lots', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id: lotId, customData: JSON.stringify(customData) })
      });
      
      if (res.ok) {
        // Update local state
        lot.customData = JSON.stringify(customData);
        tableData = [...tableData];
      }
    } catch (e) {
      console.error('Failed to update custom field:', e);
    }
  }
  
  // Bulk update custom fields for selected rows
  async function applyBulkCustomFieldEdit() {
    if (!bulkEditField || !bulkEditValue || selectedRows.size === 0) return;
    
    let updated = 0;
    let failed = 0;
    
    for (const rowId of selectedRows) {
      const lot = tableData.find(l => l.id === rowId);
      if (!lot) continue;
      
      try {
        let customData: Record<string, any> = {};
        if (lot.customData) {
          customData = typeof lot.customData === 'string' ? JSON.parse(lot.customData) : { ...lot.customData };
        }
        
        customData[bulkEditField] = bulkEditValue;
        
        const res = await fetch('/api/lots', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id: rowId, customData: JSON.stringify(customData) })
        });
        
        if (res.ok) {
          lot.customData = JSON.stringify(customData);
          updated++;
        } else {
          failed++;
        }
      } catch (e) {
        failed++;
      }
    }
    
    tableData = [...tableData];
    
    if (failed === 0) {
      log(`Updated ${bulkEditField} for ${updated} lots`, 'success');
    } else {
      log(`Updated ${updated} lots, ${failed} failed`, 'warning');
    }
    
    clearSelection();
    bulkEditField = '';
    bulkEditValue = '';
  }
  
  // Count pending inline price changes
  $: inlinePriceChangeCount = (() => {
    let count = 0;
    inlinePriceEdits.forEach((price, lotId) => {
      const lot = tableData.find(l => l.id === lotId);
      if (lot) {
        const originalPrice = parseFloat(lot.price) || 0;
        if (price !== originalPrice && price > 0) count++;
      }
    });
    return count;
  })();
  
  // Initialize pricing review for all lots in stage
  function startPricingReview() {
    if (!selectedNode || selectedNode.type !== 'stage') return;
    
    showPricingReview = true;
    log('Opened pricing review - edit prices and save all when ready', 'info');
  }
  
  // Save all pricing changes - called from PricingReviewModal
  async function handleSaveAllPrices(edits: Map<number, { price: number; pricePerSqm: number; originalPrice: number; indicativePrice: number }>) {
    if (!selectedNode || selectedNode.type !== 'stage') return;
    
    const updates: { lotId: number; price: number; pricePerSqm: number }[] = [];
    edits.forEach((edit, lotId) => {
      if (edit.price !== edit.originalPrice) {
        updates.push({ lotId, price: edit.price, pricePerSqm: edit.pricePerSqm });
      }
    });
    
    if (updates.length === 0) {
      log('No pricing changes to save', 'warning');
      return;
    }
    
    let saved = 0;
    let failed = 0;
    
    for (const update of updates) {
      try {
        const res = await fetch(`/api/lots/${update.lotId}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ price: update.price, pricePerSqm: update.pricePerSqm })
        });
        if (res.ok) {
          saved++;
          // Update local data
          const lot = tableData.find(l => l.id === update.lotId);
          if (lot) {
            lot.price = update.price;
            lot.pricePerSqm = update.pricePerSqm;
          }
        } else {
          failed++;
        }
      } catch (e) {
        failed++;
      }
    }
    
    tableData = [...tableData];
    
    if (failed === 0) {
      log(`Saved pricing for ${saved} lots`, 'success');
      showPricingReview = false;
    } else {
      log(`Saved ${saved} lots, ${failed} failed`, 'warning');
    }
  }
  
  // Cancel pricing review
  function cancelPricingReview() {
    showPricingReview = false;
    stagePriceEdits = new Map();
    log('Pricing review cancelled', 'info');
  }
  
  // Calculate summary stats for current table data (lots)
  $: tableSummary = calculateSummary(tableData, selectedNode?.type);
  
  function calculateSummary(data: any[], entityType: string | undefined) {
    if (!data || data.length === 0 || entityType !== 'stage') return null;
    
    const totalLots = data.length;
    const totalArea = data.reduce((sum, lot) => sum + (parseFloat(lot.area) || 0), 0);
    const avgArea = totalArea / totalLots;
    const totalFrontage = data.reduce((sum, lot) => sum + (parseFloat(lot.frontage) || 0), 0);
    const streetNames = [...new Set(data.map(lot => lot.streetName).filter(Boolean))];
    
    return {
      totalLots,
      totalArea: totalArea.toFixed(2),
      avgArea: avgArea.toFixed(2),
      totalFrontage: totalFrontage.toFixed(2),
      streetNames
    };
  }
  
  const entityEndpoints: Record<string, string> = {
    'company': '/api/companies',
    'project': '/api/projects',
    'precinct': '/api/precincts',
    'stage': '/api/stages',
    'lot': '/api/lots',
    'subgroup': '/api/lot-subgroups'
  };
  
  const entityFields: Record<string, Array<{key: string, label: string}>> = {
    'company': [{key: 'name', label: 'Name'}, {key: 'abn', label: 'ABN'}, {key: 'owners', label: 'Owners'}],
    'project': [{key: 'name', label: 'Name'}, {key: 'description', label: 'Description'}],
    'precinct': [{key: 'name', label: 'Name'}, {key: 'description', label: 'Description'}],
    'stage': [{key: 'name', label: 'Name'}, {key: 'description', label: 'Description'}],
    'lot': [{key: 'lotNumber', label: 'Lot #'}, {key: 'address', label: 'Address'}, {key: 'area', label: 'Area'}, {key: 'status', label: 'Status'}],
    'subgroup': [{key: 'name', label: 'Name'}, {key: 'description', label: 'Description'}]
  };
  
  $: sortedTableData = sortData(tableData, sortColumn, sortDirection);
  
  function getFieldValue(row: any, column: string): any {
    if (column === 'name') {
      return row.name || row.lotNumber || row.invoiceNumber || '';
    }
    if (column === 'description') {
      return row.description || row.status || row.address || '';
    }
    return row[column] ?? '';
  }
  
  function sortData(data: any[], column: string, direction: 'asc' | 'desc') {
    if (!column) return data;
    return [...data].sort((a, b) => {
      let aVal = getFieldValue(a, column);
      let bVal = getFieldValue(b, column);
      if (typeof aVal === 'string') aVal = aVal.toLowerCase();
      if (typeof bVal === 'string') bVal = bVal.toLowerCase();
      if (aVal < bVal) return direction === 'asc' ? -1 : 1;
      if (aVal > bVal) return direction === 'asc' ? 1 : -1;
      return 0;
    });
  }
  
  function toggleSort(column: string) {
    if (sortColumn === column) {
      sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
    } else {
      sortColumn = column;
      sortDirection = 'asc';
    }
  }
  
  const typeConfig: Record<string, {childEndpoint: string, childType: string, childKey: string}> = {
    'company': { childEndpoint: '/api/projects', childType: 'project', childKey: 'companyId' },
    'project': { childEndpoint: '/api/precincts', childType: 'precinct', childKey: 'projectId' },
    'precinct': { childEndpoint: '/api/stages', childType: 'stage', childKey: 'precinctId' },
    'stage': { childEndpoint: '/api/lots', childType: 'lot', childKey: 'stageId' },
    'lot': { childEndpoint: '/api/lot-subgroups', childType: 'subgroup', childKey: 'lotId' },
    'subgroup': { childEndpoint: '', childType: '', childKey: '' }
  };
  
  const typeLabels: Record<string, string> = {
    'company': 'CO',
    'project': 'PR', 
    'precinct': 'PC',
    'stage': 'ST',
    'lot': 'LT',
    'subgroup': 'SG'
  };
  
  const typeColors: Record<string, string> = {
    'company': '#7dcfff',
    'project': '#bb9af7',
    'precinct': '#f7768e',
    'stage': '#9ece6a',
    'lot': '#e0af68',
    'subgroup': '#73daca'
  };
  
  onMount(async () => {
    console.log('[DEBUG] onMount: starting...');
    await checkAuth();
    console.log('[DEBUG] onMount: checkAuth done, currentUser?', !!currentUser);
    if (currentUser) {
      console.log('[DEBUG] onMount: loading companies...');
      await loadCompanies();
      console.log('[DEBUG] onMount: companies loaded');
    }
    console.log('[DEBUG] onMount: complete');
  });
  
  function log(msg: string, type: 'success' | 'error' | 'loading' | 'info' | 'warning' = 'info') {
    activityLog = [...activityLog, {time: new Date().toLocaleTimeString(), message: msg, type}].slice(-20);
  }
  
  // Custom fields functions
  async function loadCustomFields(entityType: string) {
    try {
      const res = await fetch(`/api/custom-fields?entityType=${entityType}`);
      customFields = await res.json();
    } catch (e) {
      console.error('Failed to load custom fields:', e);
    }
  }
  
  async function handleFieldAdded(label: string, type: string, format: string) {
    if (!label.trim() || !selectedNode) return;
    
    const entityType = getCustomFieldEntityType();
    if (!entityType) return;
    
    const fieldKey = label.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '');
    
    try {
      const res = await fetch('/api/custom-fields', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          entityType,
          fieldKey,
          fieldLabel: label.trim(),
          fieldType: type,
          fieldFormat: format || null
        })
      });
      
      if (res.ok) {
        log(`Added custom field "${label}" to all ${entityType}s`, 'success');
        await loadCustomFields(entityType);
      }
    } catch (e) {
      log(`Failed to add custom field: ${e}`, 'error');
    }
  }
  
  function handleFieldOrderChanged(newOrder: string[]) {
    // Update field order - this is a simple reorder in memory
    // Could be persisted to user preferences if needed
    const reorderedFields = newOrder.map(key => orderedFields.find(f => f.key === key)).filter(Boolean);
    orderedFields = reorderedFields as typeof orderedFields;
  }
  
  async function removeCustomField(fieldId: number, fieldLabel: string) {
    try {
      const res = await fetch('/api/custom-fields', {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id: fieldId })
      });
      
      if (res.ok) {
        log(`Removed custom field "${fieldLabel}"`, 'success');
        const entityType = getCustomFieldEntityType();
        if (entityType) await loadCustomFields(entityType);
      }
    } catch (e) {
      log(`Failed to remove field: ${e}`, 'error');
    }
  }
  
  function toggleFieldVisibility(fieldKey: string) {
    if (hiddenFields.has(fieldKey)) {
      hiddenFields.delete(fieldKey);
    } else {
      hiddenFields.add(fieldKey);
    }
    hiddenFields = new Set(hiddenFields); // Trigger reactivity
  }
  
  // Format number with specified format
  function formatNumber(value: any, format: string = ''): string {
    if (value === null || value === undefined || value === '') return '-';
    const num = parseFloat(value);
    if (isNaN(num)) return value;
    
    const formatted = num.toLocaleString('en-AU', { maximumFractionDigits: 2 });
    
    switch (format) {
      case '$':
        return `$${formatted}`;
      case 'sqm':
        return `${formatted} sqm`;
      case 'm':
        return `${formatted} m`;
      default:
        return formatted;
    }
  }
  
  // Get status option by value
  function getStatusOption(value: string) {
    return statusOptions.find(s => s.value === value) || statusOptions[0];
  }
  
  // Field drag and drop handlers
  function handleFieldDragStart(e: DragEvent, fieldKey: string) {
    draggingField = fieldKey;
    if (e.dataTransfer) {
      e.dataTransfer.effectAllowed = 'move';
    }
  }
  
  function handleFieldDragOver(e: DragEvent) {
    e.preventDefault();
  }
  
  function handleFieldDrop(e: DragEvent, targetFieldKey: string) {
    e.preventDefault();
    if (!draggingField || draggingField === targetFieldKey) return;
    
    const currentOrder = [...fieldOrder];
    const fromIndex = currentOrder.indexOf(draggingField);
    const toIndex = currentOrder.indexOf(targetFieldKey);
    
    if (fromIndex !== -1 && toIndex !== -1) {
      currentOrder.splice(fromIndex, 1);
      currentOrder.splice(toIndex, 0, draggingField);
      fieldOrder = currentOrder;
    }
    draggingField = null;
  }
  
  function handleFieldDragEnd() {
    draggingField = null;
  }
  
  // Column resize handlers
  function startColumnResize(e: MouseEvent, columnKey: string) {
    e.preventDefault();
    e.stopPropagation();
    resizingColumn = columnKey;
    resizeStartX = e.clientX;
    resizeStartWidth = columnWidths[columnKey] || 100;
    
    document.addEventListener('mousemove', handleColumnResize);
    document.addEventListener('mouseup', stopColumnResize);
  }
  
  function handleColumnResize(e: MouseEvent) {
    if (!resizingColumn) return;
    const diff = e.clientX - resizeStartX;
    const newWidth = Math.max(50, resizeStartWidth + diff);
    columnWidths = { ...columnWidths, [resizingColumn]: newWidth };
  }
  
  function stopColumnResize() {
    resizingColumn = null;
    document.removeEventListener('mousemove', handleColumnResize);
    document.removeEventListener('mouseup', stopColumnResize);
  }
  
  function getColumnWidth(key: string): string {
    return columnWidths[key] ? `${columnWidths[key]}px` : 'auto';
  }
  
  // Initialize field order when custom fields change
  $: {
    const defaultFields = selectedNode?.type === 'stage' 
      ? ['lotNumber', 'area', 'frontage', 'depth', 'streetName', 'status']
      : ['name', 'description'];
    const customFieldKeys = customFields.map(f => f.fieldKey);
    const allFields = [...defaultFields, ...customFieldKeys];
    
    // Clean up removed fields and add missing fields
    const currentValidFields = fieldOrder.filter(f => allFields.includes(f));
    const missingFields = allFields.filter(f => !fieldOrder.includes(f));
    
    if (missingFields.length > 0 || currentValidFields.length !== fieldOrder.length) {
      fieldOrder = [...currentValidFields, ...missingFields];
    }
  }
  
  // Reactive ordered visible fields - updates when fieldOrder, customFields, or hiddenFields change
  $: orderedFields = (() => {
    const defaultFields = selectedNode?.type === 'stage'
      ? [
          { key: 'lotNumber', label: 'Lot #', type: 'text', format: '', isCustom: false },
          { key: 'area', label: 'Area', type: 'number', format: 'sqm', isCustom: false },
          { key: 'frontage', label: 'Front', type: 'number', format: 'm', isCustom: false },
          { key: 'depth', label: 'Depth', type: 'number', format: 'm', isCustom: false },
          { key: 'streetName', label: 'Street', type: 'text', format: '', isCustom: false },
          { key: 'status', label: 'Status', type: 'status', format: '', isCustom: false },
          { key: 'price', label: 'Price', type: 'number', format: '$', isCustom: false }
        ]
      : selectedNode?.type === 'precinct'
        ? [
            { key: 'name', label: 'Name', type: 'text', format: '', isCustom: false },
            { key: 'description', label: 'Description', type: 'text', format: '', isCustom: false },
            { key: 'registrationDate', label: 'Reg Date', type: 'date', format: '', isCustom: false }
          ]
        : [
            { key: 'name', label: 'Name', type: 'text', format: '', isCustom: false },
            { key: 'description', label: 'Description', type: 'text', format: '', isCustom: false }
          ];
    
    const customFieldsList = customFields.map(f => ({
      key: f.fieldKey,
      label: f.fieldLabel,
      type: f.fieldType,
      format: f.fieldFormat || '',
      isCustom: true
    }));
    
    const allFields = [...defaultFields, ...customFieldsList];
    
    // Sort by fieldOrder
    return allFields
      .filter(f => !hiddenFields.has(f.key))
      .sort((a, b) => {
        const aIndex = fieldOrder.indexOf(a.key);
        const bIndex = fieldOrder.indexOf(b.key);
        if (aIndex === -1 && bIndex === -1) return 0;
        if (aIndex === -1) return 1;
        if (bIndex === -1) return -1;
        return aIndex - bIndex;
      });
  })();
  
  // Reactive all fields for the fields manager (including hidden)
  $: allFieldsList = (() => {
    const defaultFields = selectedNode?.type === 'stage'
      ? [
          { key: 'lotNumber', label: 'Lot #', type: 'text', format: '', isDefault: true, id: undefined as number | undefined },
          { key: 'area', label: 'Area', type: 'number', format: 'sqm', isDefault: true, id: undefined as number | undefined },
          { key: 'frontage', label: 'Frontage', type: 'number', format: 'm', isDefault: true, id: undefined as number | undefined },
          { key: 'depth', label: 'Depth', type: 'number', format: 'm', isDefault: true, id: undefined as number | undefined },
          { key: 'streetName', label: 'Street', type: 'text', format: '', isDefault: true, id: undefined as number | undefined },
          { key: 'status', label: 'Status', type: 'status', format: '', isDefault: true, id: undefined as number | undefined },
          { key: 'price', label: 'Price', type: 'number', format: '$', isDefault: true, id: undefined as number | undefined }
        ]
      : selectedNode?.type === 'precinct'
        ? [
            { key: 'name', label: 'Name', type: 'text', format: '', isDefault: true, id: undefined as number | undefined },
            { key: 'description', label: 'Description', type: 'text', format: '', isDefault: true, id: undefined as number | undefined },
            { key: 'registrationDate', label: 'Reg Date', type: 'date', format: '', isDefault: true, id: undefined as number | undefined }
          ]
        : [
            { key: 'name', label: 'Name', type: 'text', format: '', isDefault: true, id: undefined as number | undefined },
            { key: 'description', label: 'Description', type: 'text', format: '', isDefault: true, id: undefined as number | undefined }
          ];
    
    const customFieldsList = customFields.map(f => ({
      key: f.fieldKey,
      label: f.fieldLabel,
      type: f.fieldType,
      format: f.fieldFormat || '',
      isDefault: false,
      id: f.id
    }));
    
    const allFields = [...defaultFields, ...customFieldsList];
    
    // Sort by fieldOrder
    return allFields.sort((a, b) => {
      const aIndex = fieldOrder.indexOf(a.key);
      const bIndex = fieldOrder.indexOf(b.key);
      if (aIndex === -1 && bIndex === -1) return 0;
      if (aIndex === -1) return 1;
      if (bIndex === -1) return -1;
      return aIndex - bIndex;
    });
  })();
  
  function getCustomFieldEntityType(): string | null {
    if (!selectedNode) return null;
    // When viewing a stage, we're looking at lots
    if (selectedNode.type === 'stage') return 'lot';
    // When viewing a precinct, we're looking at stages
    if (selectedNode.type === 'precinct') return 'stage';
    // When viewing a project, we're looking at precincts
    if (selectedNode.type === 'project') return 'precinct';
    // When viewing a company, we're looking at projects
    if (selectedNode.type === 'company') return 'project';
    return null;
  }
  
  function getCustomFieldValue(row: any, fieldKey: string): string {
    if (row.customData) {
      try {
        const data = typeof row.customData === 'string' ? JSON.parse(row.customData) : row.customData;
        return data[fieldKey] || '';
      } catch {
        return '';
      }
    }
    return '';
  }
  
  async function loadCompanies() {
    log('Loading companies...', 'loading');
    const res = await fetch('/api/companies');
    const companies = await res.json();
    tree = companies.map((c: any) => ({ id: c.id, name: c.name, type: 'company', parentId: null }));
    log(`Loaded ${tree.length} companies`, 'success');
  }
  
  async function handleCreateCompany(name: string, abn: string | null) {
    try {
      const res = await fetch('/api/companies', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, abn })
      });
      
      if (res.ok) {
        const newCompany = await res.json();
        log(`Created company: ${newCompany.name}`, 'success');
        await loadCompanies();
        showNewCompanyModal = false;
      } else {
        const data = await res.json();
        log(data.error || 'Failed to create company', 'error');
        throw new Error(data.error || 'Failed to create company');
      }
    } catch (e) {
      log('Failed to create company', 'error');
      throw e;
    }
  }
  
  function findNodeById(nodes: TreeNode[], id: number): TreeNode | undefined {
    for (const node of nodes) {
      if (node.id === id) return node;
      if (node.children) {
        const found = findNodeById(node.children, id);
        if (found) return found;
      }
    }
    return undefined;
  }
  
  async function toggleNode(node: TreeNode) {
    if (node.expanded) {
      node.expanded = false;
      tree = [...tree];
      return;
    }
    
    const config = typeConfig[node.type];
    if (!config.childEndpoint) return;
    
    node.loading = true;
    tree = [...tree];
    
    log(`Loading ${config.childType}s...`, 'loading');
    const res = await fetch(`${config.childEndpoint}?${config.childKey}=${node.id}`);
    const children = await res.json();
    
    node.children = children.map((c: any) => ({
      id: c.id,
      name: c.name || c.lotNumber || `#${c.id}`,
      type: config.childType,
      parentId: node.id
    }));
    node.expanded = true;
    node.loading = false;
    tree = [...tree];
    log(`Loaded ${children.length} ${config.childType}s`, 'success');
  }
  
  async function selectNode(node: TreeNode) {
    selectedNode = node;
    editingId = null;
    isAdding = false;
    editingProperty = null;
    log(`Selected ${node.name}`, 'info');

    // Load and apply saved preferences for this node
    const prefs = await loadNodePreferences(node.type, node.id);
    if (prefs.showSummary !== undefined) showSummary = prefs.showSummary === 'true';
    if (prefs.showProperties !== undefined) showProperties = prefs.showProperties === 'true';
    
    // Build hierarchy path by traversing up the tree
    hierarchyPath = [];
    let currentNode: TreeNode | undefined = node;
    while (currentNode) {
      hierarchyPath.unshift({ type: currentNode.type, name: currentNode.name });
      if (currentNode.parentId) {
        currentNode = findNodeById(tree, currentNode.parentId);
      } else {
        break;
      }
    }
    
    // Fetch full entity details
    const endpoint = entityEndpoints[node.type];
    if (endpoint) {
      const detailRes = await fetch(`${endpoint}?id=${node.id}`);
      const details = await detailRes.json();
      entityDetails = Array.isArray(details) ? details.find((d: any) => d.id === node.id) : details;
    }
    
    const config = typeConfig[node.type];
    if (!config.childEndpoint) {
      tableData = [];
      return;
    }
    
    loading = true;
    const res = await fetch(`${config.childEndpoint}?${config.childKey}=${node.id}`);
    tableData = await res.json();
    loading = false;
    
    // Load custom fields for the child entity type
    const childEntityType = getCustomFieldEntityType();
    if (childEntityType) {
      await loadCustomFields(childEntityType);
    }
    
    // Load pricing when viewing a project (PricingPanel displays at project level)
    if (node.type === 'project') {
      await loadPricing(node.id);
      const pricedCount = pricingProducts.filter(p => p.basePrice > 0).length;
      if (pricedCount > 0) {
        log(`Loaded ${pricedCount} priced products`, 'info');
      }
    }

    // Load pricing when viewing a stage (fetch project ID via stage -> precinct -> project)
    if (node.type === 'stage') {
      try {
        // Fetch all stages with precinct relation to find this stage's project
        const stagesRes = await fetch('/api/stages');
        const allStages = await stagesRes.json();
        const thisStage = allStages.find((s: any) => s.id === node.id);
        
        const projectId = thisStage?.precinct?.projectId;
        if (projectId) {
          await loadPricing(projectId);
          const pricedCount = pricingProducts.filter(p => p.basePrice > 0).length;
          if (pricedCount > 0) {
            log(`Loaded ${pricedCount} priced products`, 'info');
          }
        }
      } catch (e) {
        console.error('Failed to load pricing for stage:', e);
      }
    }
    
    // Reload Documents
    await loadDocuments();
  }
  
  // Helper to find node by type and name
  function findNodeByTypeAndName(nodes: TreeNode[], type: string, name: string): TreeNode | undefined {
    for (const node of nodes) {
      if (node.type === type && node.name === name) return node;
      if (node.children) {
        const found = findNodeByTypeAndName(node.children, type, name);
        if (found) return found;
      }
    }
    return undefined;
  }
  
  function startPropertyEdit(key: string) {
    editingProperty = key;
    // Handle date fields - convert ISO date to YYYY-MM-DD for date input
    if ((key === 'registrationDate' || key === 'settlementDate') && entityDetails?.[key]) {
      const date = new Date(entityDetails[key]);
      propertyEditValue = date.toISOString().split('T')[0];
    } else {
      propertyEditValue = entityDetails?.[key] || '';
    }
  }
  
  function cancelPropertyEdit() {
    editingProperty = null;
    propertyEditValue = '';
  }
  
  async function handlePropertySave(field: string, value: string | null) {
    if (!selectedNode) return;
    const endpoint = entityEndpoints[selectedNode.type];
    
    // Handle date fields - convert to ISO timestamp
    let valueToSave: string | null = value;
    if (field === 'registrationDate' || field === 'settlementDate') {
      valueToSave = value ? new Date(value).toISOString() : null;
    }
    
    try {
      const res = await fetch(endpoint, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id: selectedNode.id, [field]: valueToSave })
      });
      if (res.ok) {
        entityDetails = { ...entityDetails, [field]: valueToSave };
        // Update tree node name if name was changed
        if (field === 'name' || field === 'lotNumber') {
          selectedNode.name = value || '';
          tree = [...tree];
        }
        log(`Updated ${field}`, 'success');
      } else {
        log('Update failed', 'error');
      }
    } catch (e) {
      log('Update error', 'error');
    }
  }
  
  async function loadDocuments() {
    if (!selectedNode) return;
    const res = await fetch(`/api/documents?entityType=${selectedNode.type}&entityId=${selectedNode.id}`);
    documents = await res.json();
  }
  
  // Helper function to reload table data for current selected node
  async function reloadTableData() {
    if (!selectedNode) return;
    const config = typeConfig[selectedNode.type];
    if (config?.childEndpoint) {
      const res = await fetch(`${config.childEndpoint}?${config.childKey}=${selectedNode.id}`);
      tableData = await res.json();
    }
  }
  
  async function handleDocumentUpload(file: File, documentType: string) {
    if (!selectedNode) return;
    
    log('Uploading document...', 'loading');
    
    const formData = new FormData();
    formData.append('file', file);
    formData.append('entityType', selectedNode.type);
    formData.append('entityId', selectedNode.id.toString());
    formData.append('documentType', documentType);
    
    try {
      const res = await fetch('/api/documents', {
        method: 'POST',
        body: formData
      });
      if (res.ok) {
        const doc = await res.json();
        documents = [...documents, doc];
        log('Document uploaded', 'success');
      } else {
        const errData = await res.json().catch(() => ({}));
        log(`Upload failed: ${errData.error || res.statusText}`, 'error');
      }
    } catch (e: any) {
      log(`Upload error: ${e.message}`, 'error');
    }
  }
  
  async function extractFromDocument(docId: number, reanalyze: boolean = false) {
    extractingDocId = docId;
    log(reanalyze ? 'Re-analyzing with AI...' : 'Extracting data with AI...', 'loading');
    
    try {
      const res = await fetch('/api/documents/extract', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ documentId: docId, extractionType: 'stage' })
      });
      
      if (res.ok) {
        const extracted = await res.json();
        
        if (reanalyze && extracted.lots && selectedNode) {
          // Re-analyze mode: Match extracted lots against existing lots
          const existingLots = tableData;
          extracted.lots = extracted.lots.map((lot: any) => {
            // Try to find matching existing lot by lot number
            const match = existingLots.find((existing: any) => 
              existing.lotNumber?.toLowerCase() === lot.lotNumber?.toLowerCase()
            );
            
            if (match) {
              // Found a match - mark for update
              return {
                ...lot,
                existingId: match.id,
                existingData: match,
                action: 'update',
                hasChanges: checkForChanges(match, lot)
              };
            } else {
              // No match - mark for create
              return {
                ...lot,
                existingId: null,
                existingData: null,
                action: 'create'
              };
            }
          });
          
          const updates = extracted.lots?.filter((l: any) => l.action === 'update').length || 0;
          const creates = extracted.lots?.filter((l: any) => l.action === 'create').length || 0;
          log(`Found ${updates} updates, ${creates} new lots`, 'success');
        } else {
          // First extraction mode: All lots are new creates
          if (extracted.lots) {
            extracted.lots = extracted.lots.map((lot: any) => ({
              ...lot,
              existingId: null,
              existingData: null,
              action: 'create'
            }));
          }
          log(`Extracted ${extracted.lots?.length || 0} lots`, 'success');
        }
        
        extractionResult = extracted;
        showExtractionModal = true;
      } else {
        log('Extraction failed', 'error');
      }
    } catch (e) {
      log('Extraction error', 'error');
    }
    extractingDocId = null;
  }
  
  function checkForChanges(existing: any, extracted: any): boolean {
    const parseNum = (val: any) => {
      if (!val) return null;
      const match = val.toString().match(/[\d.]+/);
      return match ? parseFloat(match[0]) : null;
    };
    
    return (
      parseNum(extracted.area) !== parseFloat(existing.area) ||
      parseNum(extracted.frontage) !== parseFloat(existing.frontage) ||
      parseNum(extracted.depth) !== parseFloat(existing.depth) ||
      (extracted.streetName && extracted.streetName !== existing.streetName)
    );
  }
  
  // Open pre-extraction modal to allow user to add context
  function openPreExtractionModal(docId: number) {
    pendingExtractionDocId = docId;
    extractionHints = ''; // Reset hints for new extraction
    showPreExtractionModal = true;
  }
  
  // Start extraction after user confirms (with optional hints)
  function confirmExtraction() {
    if (pendingExtractionDocId) {
      showPreExtractionModal = false;
      extractPermitPlan(pendingExtractionDocId);
    }
  }
  
  // Cancel pre-extraction modal
  function cancelPreExtraction() {
    showPreExtractionModal = false;
    pendingExtractionDocId = null;
    extractionHints = '';
  }
  
  // Permit Plan extraction for Precincts - extracts multiple stages and lots
  async function extractPermitPlan(docId: number) {
    extractingDocId = docId;
    extractionProgress = { current: 0, total: 0, status: 'Starting extraction...' };
    const modelName = modelOptions.find(m => m.id === selectedModel)?.name || selectedModel;
    log(`Analyzing Permit Plan using ${modelName}...`, 'loading');
    
    // Start progress animation
    extractionProgress = { current: 0, total: 100, status: 'Converting PDF pages to images...' };
    const progressInterval = setInterval(() => {
      if (extractionProgress.current < 90) {
        extractionProgress.current += 2;
        if (extractionProgress.current < 30) {
          extractionProgress.status = 'Converting PDF pages to images...';
        } else if (extractionProgress.current < 70) {
          extractionProgress.status = 'AI analyzing document...';
        } else {
          extractionProgress.status = 'Processing extracted data...';
        }
      }
    }, 500);
    
    try {
      const res = await fetch('/api/documents/extract', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          documentId: docId, 
          extractionType: 'precinct', 
          model: selectedModel,
          hints: extractionHints || undefined
        })
      });
      
      clearInterval(progressInterval);
      extractionProgress = { current: 100, total: 100, status: 'Complete!' };
      
      if (res.ok) {
        const extracted = await res.json();
        
        if (extracted.stages && extracted.stages.length > 0) {
          // Mark all stages for creation with their lots
          extracted.stages = extracted.stages.map((stage: any) => ({
            ...stage,
            action: 'create',
            lots: (stage.lots || []).map((lot: any) => ({
              ...lot,
              action: 'create'
            }))
          }));
          const totalLots = extracted.stages.reduce((sum: number, s: any) => sum + (s.lots?.length || 0), 0);
          const pageInfo = extracted.pageCount > 1 ? ` (from ${extracted.pageCount} pages)` : '';
          log(`Found ${extracted.stages.length} stages with ${totalLots} total lots${pageInfo}`, 'success');
          
          // Check if there's more data to extract
          if (extracted.hasMore) {
            const remaining = extracted.remainingStages || [];
            const estLots = extracted.estimatedRemainingLots || 0;
            log(`â ï¸ More data available: ${remaining.join(', ')} (~${estLots} lots remaining)`, 'loading');
            continuationInfo = { 
              docId, 
              remainingStages: remaining, 
              estimatedLots: estLots,
              existingData: extracted
            };
            showContinueModal = true;
          }
        } else if (extracted.lots && extracted.lots.length > 0) {
          // Fallback: If no stages found but lots exist, wrap in single stage
          extracted.stages = [{
            stageName: 'Stage 1',
            stageNumber: '1',
            action: 'create',
            lots: extracted.lots.map((lot: any) => ({ ...lot, action: 'create' }))
          }];
          const pageInfo = extracted.pageCount > 1 ? ` (from ${extracted.pageCount} pages)` : '';
          log(`Found ${extracted.lots.length} lots (single stage)${pageInfo}`, 'success');
        } else {
          log('No stages or lots found in permit plan', 'error');
        }
        
        extractionResult = extracted;
        showExtractionModal = true;
      } else {
        const errData = await res.json();
        const details = errData.filename ? ` [file: ${errData.filename}, isUrl: ${errData.isUrl}]` : '';
        log(`Extraction failed: ${errData.error || 'Unknown error'}${details}`, 'error');
      }
    } catch (e: any) {
      clearInterval(progressInterval);
      log(`Extraction error: ${e.message || e}`, 'error');
    }
    extractingDocId = null;
    extractionProgress = { current: 0, total: 0, status: '' };
  }
  
  // Continue extraction for remaining stages
  async function continueExtraction() {
    if (!continuationInfo) return;
    
    const { docId, remainingStages, existingData } = continuationInfo;
    showContinueModal = false;
    extractingDocId = docId;
    
    const modelName = modelOptions.find(m => m.id === selectedModel)?.name || selectedModel;
    log(`Continuing extraction for ${remainingStages.join(', ')} using ${modelName}...`, 'loading');
    
    extractionProgress = { current: 0, total: 100, status: 'Continuing extraction...' };
    const progressInterval = setInterval(() => {
      if (extractionProgress.current < 90) {
        extractionProgress.current += 2;
        extractionProgress.status = `Extracting ${remainingStages[0] || 'remaining stages'}...`;
      }
    }, 500);
    
    try {
      const res = await fetch('/api/documents/extract', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          documentId: docId, 
          extractionType: 'precinct', 
          model: selectedModel,
          continueFrom: remainingStages,
          excludeStages: existingData.stages?.map((s: any) => s.stageName || s.stageNumber) || []
        })
      });
      
      clearInterval(progressInterval);
      extractionProgress = { current: 100, total: 100, status: 'Complete!' };
      
      if (res.ok) {
        const newData = await res.json();
        
        // Merge new stages with existing
        if (newData.stages && newData.stages.length > 0) {
          const mergedStages = [
            ...(existingData.stages || []),
            ...newData.stages.map((stage: any) => ({
              ...stage,
              action: 'create',
              lots: (stage.lots || []).map((lot: any) => ({ ...lot, action: 'create' }))
            }))
          ];
          
          const totalLots = mergedStages.reduce((sum: number, s: any) => sum + (s.lots?.length || 0), 0);
          log(`Total: ${mergedStages.length} stages with ${totalLots} lots`, 'success');
          
          extractionResult = { ...existingData, stages: mergedStages };
          
          // Check if still more data
          if (newData.hasMore) {
            continuationInfo = {
              docId,
              remainingStages: newData.remainingStages || [],
              estimatedLots: newData.estimatedRemainingLots || 0,
              existingData: extractionResult
            };
            showContinueModal = true;
          } else {
            continuationInfo = null;
            // Show the extraction results modal when continuation is complete
            showExtractionModal = true;
          }
        } else {
          // No new stages found, still show what we have
          log('No additional stages found in continuation', 'info');
          showExtractionModal = true;
        }
      } else {
        const errData = await res.json();
        log(`Continuation failed: ${errData.error || 'Unknown error'}`, 'error');
        // Still show existing data
        showExtractionModal = true;
      }
    } catch (e: any) {
      clearInterval(progressInterval);
      log(`Continuation error: ${e.message || e}`, 'error');
    }
    
    extractingDocId = null;
    extractionProgress = { current: 0, total: 0, status: '' };
  }
  
  // Cross-reference Plan of Subdivision against existing lot data
  async function crossReferenceDocument(docId: number) {
    extractingDocId = docId;
    const modelName = modelOptions.find(m => m.id === selectedModel)?.name || selectedModel;
    log(`Cross-referencing document using ${modelName}...`, 'loading');
    
    try {
      const res = await fetch('/api/documents/cross-reference', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          documentId: docId, 
          model: selectedModel,
          entityType: selectedNode?.type,
          entityId: selectedNode?.id
        })
      });
      
      if (res.ok) {
        const result = await res.json();
        
        if (result.matches && result.matches.length > 0) {
          // Show cross-reference results in verification modal
          verificationResult = {
            ...result,
            corrections: result.matches.filter((m: any) => m.hasDiscrepancy).map((m: any) => ({
              lotNumber: m.lotNumber,
              field: m.discrepancyField,
              currentValue: m.existingValue,
              correctValue: m.extractedValue,
              confidence: m.confidence,
              lotId: m.lotId
            }))
          };
          showVerificationModal = true;
          
          const discrepancies = result.matches.filter((m: any) => m.hasDiscrepancy).length;
          log(`Found ${result.matches.length} matching lots, ${discrepancies} with discrepancies`, discrepancies > 0 ? 'info' : 'success');
        } else {
          log('No matching lots found in document', 'error');
        }
      } else {
        const errData = await res.json();
        log(`Cross-reference failed: ${errData.error || 'Unknown error'}`, 'error');
      }
    } catch (e: any) {
      log(`Cross-reference error: ${e.message || e}`, 'error');
    }
    extractingDocId = null;
  }
  
  // Analyze Plan of Subdivision - comprehensive analysis with easements
  async function analyzePlanOfSubdivision(docId: number) {
    extractingDocId = docId;
    analyzingPos = true;
    const modelName = modelOptions.find(m => m.id === selectedModel)?.name || selectedModel;
    log(`Analyzing Plan of Subdivision using ${modelName}...`, 'loading');
    
    try {
      const res = await fetch('/api/documents/analyze-pos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          documentId: docId, 
          model: selectedModel,
          stageId: selectedNode?.id
        })
      });
      
      if (res.ok) {
        posAnalysisResult = await res.json();
        showPosAnalysisModal = true;
        expandedLots = new Set();
        
        const { summary } = posAnalysisResult;
        log(`POS Analysis: ${summary.matches} match, ${summary.variances} variances, ${summary.lotsWithEasements} with easements`, 
          summary.variances > 0 ? 'info' : 'success');
      } else {
        const errData = await res.json();
        log(`POS Analysis failed: ${errData.error || 'Unknown error'}`, 'error');
      }
    } catch (e: any) {
      log(`POS Analysis error: ${e.message || e}`, 'error');
    }
    extractingDocId = null;
    analyzingPos = false;
  }
  
  // Toggle expanded state for lot details
  function toggleLotExpanded(lotNumber: string) {
    if (expandedLots.has(lotNumber)) {
      expandedLots.delete(lotNumber);
    } else {
      expandedLots.add(lotNumber);
    }
    expandedLots = expandedLots; // Trigger reactivity
  }
  
  // Filter comparisons based on selected filter
  function getFilteredComparisons() {
    if (!posAnalysisResult?.comparisons) return [];
    
    switch (posAnalysisFilter) {
      case 'variance':
        return posAnalysisResult.comparisons.filter((c: any) => c.status === 'variance');
      case 'easements':
        return posAnalysisResult.comparisons.filter((c: any) => 
          c.newInfo?.easements?.length > 0 || c.newInfo?.encumbrances?.length > 0
        );
      case 'match':
        return posAnalysisResult.comparisons.filter((c: any) => c.status === 'match');
      default:
        return posAnalysisResult.comparisons;
    }
  }
  
  // Apply a single correction from POS analysis
  async function applyPosCorrection(correction: any) {
    if (!correction.lotId) return;
    
    try {
      const res = await fetch(`/api/lots/${correction.lotId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ [correction.field]: correction.newValue })
      });
      
      if (res.ok) {
        log(`Updated Lot ${correction.lotNumber} ${correction.field}: ${correction.currentValue} â ${correction.newValue}`, 'success');
        // Remove from corrections list
        posAnalysisResult.corrections = posAnalysisResult.corrections.filter(
          (c: any) => !(c.lotId === correction.lotId && c.field === correction.field)
        );
        // Update comparison status
        const comp = posAnalysisResult.comparisons.find((c: any) => c.lotId === correction.lotId);
        if (comp) {
          comp.variances = comp.variances.filter((v: any) => v.field !== correction.field);
          if (comp.variances.length === 0) {
            comp.status = comp.newInfo?.easements?.length > 0 ? 'new_data' : 'match';
          }
        }
        posAnalysisResult = posAnalysisResult; // Trigger reactivity
        await reloadTableData();
      }
    } catch (e: any) {
      log(`Error applying correction: ${e.message}`, 'error');
    }
  }
  
  // Apply all corrections from POS analysis
  async function applyAllPosCorrections() {
    if (!posAnalysisResult?.corrections?.length) return;
    
    log(`Applying ${posAnalysisResult.corrections.length} corrections...`, 'loading');
    let applied = 0;
    
    for (const correction of [...posAnalysisResult.corrections]) {
      await applyPosCorrection(correction);
      applied++;
    }
    
    log(`Applied ${applied} corrections from POS`, 'success');
  }
  
  // Save extracted stages and lots from Permit Plan
  async function saveExtractedStages() {
    if (!selectedNode || !extractionResult?.stages || savingExtraction) {
      log('No stages to save', 'error');
      return;
    }
    
    if (selectedNode.type !== 'precinct') {
      log('Please select a Precinct to save stages', 'error');
      return;
    }
    
    savingExtraction = true;
    log('Creating stages and lots...', 'loading');
    let stagesCreated = 0;
    let lotsCreated = 0;
    let errors = 0;
    
    const parseNumeric = (val: any) => {
      if (!val) return null;
      const match = val.toString().match(/[\d.]+/);
      return match ? match[0] : null;
    };
    
    for (const stage of extractionResult.stages) {
      if (stage.action === 'skip') continue;
      
      try {
        // Create stage
        const stageRes = await fetch('/api/stages', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            precinctId: selectedNode.id,
            name: stage.stageName || `Stage ${stage.stageNumber || stagesCreated + 1}`
          })
        });
        
        if (stageRes.ok) {
          const newStage = await stageRes.json();
          stagesCreated++;
          
          // Create lots for this stage
          for (const lot of (stage.lots || [])) {
            if (lot.action === 'skip') continue;
            
            try {
              const lotRes = await fetch('/api/lots', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  stageId: newStage.id,
                  lotNumber: lot.lotNumber,
                  area: parseNumeric(lot.area),
                  frontage: parseNumeric(lot.frontage),
                  depth: parseNumeric(lot.depth),
                  streetName: lot.streetName || null,
                  status: 'extracted'
                })
              });
              if (lotRes.ok) lotsCreated++;
              else errors++;
            } catch {
              errors++;
            }
          }
        } else {
          errors++;
        }
      } catch {
        errors++;
      }
    }
    
    if (stagesCreated > 0) {
      log(`Created ${stagesCreated} stages, ${lotsCreated} lots${errors > 0 ? `, ${errors} errors` : ''}`, 'success');
      // Refresh tree to show new stages
      if (selectedNode.expanded) {
        await toggleNode(selectedNode);
        await toggleNode(selectedNode);
      }
    } else {
      log(`Failed to create stages (${errors} errors)`, 'error');
    }
    
    savingExtraction = false;
    showExtractionModal = false;
    extractionResult = null;
  }
  
  async function saveExtractedLots() {
    if (!selectedNode || !extractionResult?.lots || savingExtraction) {
      log('No data to save', 'error');
      return;
    }
    
    if (selectedNode.type !== 'stage') {
      log('Please select a Stage to save lots', 'error');
      return;
    }
    
    savingExtraction = true;
    log('Saving extracted lots...', 'loading');
    let updated = 0;
    let created = 0;
    let skipped = 0;
    let errors = 0;
    
    // Parse numeric values helper
    const parseNumeric = (val: any) => {
      if (!val) return null;
      const match = val.toString().match(/[\d.]+/);
      return match ? match[0] : null;
    };
    
    for (const lot of extractionResult.lots) {
      // Skip if action is 'skip'
      if (lot.action === 'skip') {
        skipped++;
        continue;
      }
      
      try {
        const lotData: any = {
          lotNumber: lot.lotNumber || `Lot ${created + 1}`,
          address: lot.address || `${lot.lotNumber || ''} ${lot.streetName || ''}`.trim() || null,
          area: parseNumeric(lot.area),
          frontage: parseNumeric(lot.frontage),
          depth: parseNumeric(lot.depth),
          streetName: lot.streetName || null,
          status: lot.status || 'extracted'
        };
        
        if (lot.action === 'update' && lot.existingId) {
          // Update existing lot
          lotData.id = lot.existingId;
          const res = await fetch('/api/lots', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(lotData)
          });
          if (res.ok) updated++;
          else errors++;
        } else {
          // Create new lot
          lotData.stageId = selectedNode.id;
          const res = await fetch('/api/lots', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(lotData)
          });
          if (res.ok) created++;
          else errors++;
        }
      } catch (e) {
        console.error('Error saving lot:', e);
        errors++;
      }
    }
    
    const total = updated + created;
    if (total > 0) {
      const parts = [];
      if (updated > 0) parts.push(`${updated} updated`);
      if (created > 0) parts.push(`${created} created`);
      if (skipped > 0) parts.push(`${skipped} skipped`);
      if (errors > 0) parts.push(`${errors} failed`);
      log(parts.join(', '), 'success');
    } else if (skipped > 0) {
      log(`${skipped} lots skipped`, 'info');
    } else {
      log(`Failed to save lots (${errors} errors)`, 'error');
    }
    
    savingExtraction = false;
    showExtractionModal = false;
    extractionResult = null;
    
    // Refresh table data
    if (selectedNode) {
      const config = typeConfig[selectedNode.type];
      if (config.childEndpoint) {
        const res = await fetch(`${config.childEndpoint}?${config.childKey}=${selectedNode.id}`);
        tableData = await res.json();
      }
    }
  }
  
  async function deleteDocument(docId: number) {
    try {
      await fetch('/api/documents', {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id: docId })
      });
      documents = documents.filter(d => d.id !== docId);
      log('Document deleted', 'success');
    } catch (e) {
      log('Delete error', 'error');
    }
  }
  
  // Bulk edit functions
  function toggleRowSelection(id: number) {
    if (selectedRows.has(id)) {
      selectedRows.delete(id);
    } else {
      selectedRows.add(id);
    }
    selectedRows = new Set(selectedRows); // Trigger reactivity
  }
  
  function toggleAllRows() {
    if (selectedRows.size === tableData.length) {
      selectedRows = new Set();
    } else {
      selectedRows = new Set(tableData.map(r => r.id));
    }
  }
  
  function clearSelection() {
    selectedRows = new Set();
    showBulkEdit = false;
    bulkEditField = '';
    bulkEditValue = '';
  }
  
  async function applyBulkEdit() {
    if (selectedRows.size === 0 || !bulkEditField || !selectedNode) {
      log('Select rows and field to update', 'error');
      return;
    }
    
    log(`Updating ${selectedRows.size} rows...`, 'loading');
    let updated = 0;
    let errors = 0;
    
    const endpoint = typeConfig[selectedNode.type]?.childEndpoint;
    if (!endpoint) return;
    
    for (const id of selectedRows) {
      try {
        const updateData: any = { id };
        // Parse numeric values for specific fields
        if (['area', 'frontage', 'depth'].includes(bulkEditField)) {
          const numMatch = bulkEditValue.match(/[\d.]+/);
          updateData[bulkEditField] = numMatch ? numMatch[0] : null;
        } else {
          updateData[bulkEditField] = bulkEditValue;
        }
        
        const res = await fetch(endpoint, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(updateData)
        });
        if (res.ok) updated++;
        else errors++;
      } catch {
        errors++;
      }
    }
    
    if (updated > 0) {
      log(`Updated ${updated} rows${errors > 0 ? `, ${errors} failed` : ''}`, 'success');
      // Refresh table
      const config = typeConfig[selectedNode.type];
      if (config.childEndpoint) {
        const res = await fetch(`${config.childEndpoint}?${config.childKey}=${selectedNode.id}`);
        tableData = await res.json();
      }
    } else {
      log(`Failed to update (${errors} errors)`, 'error');
    }
    
    clearSelection();
  }
  
  // Analyze specific PDF page and compare with existing lot data
  async function analyzePageForVerification() {
    if (!inlineDocument || inlineDocument.mimeType !== 'application/pdf') {
      log('No PDF document selected', 'error');
      return;
    }
    
    const modelName = modelOptions.find(m => m.id === selectedModel)?.name || selectedModel;
    analyzingPage = true;
    log(`Extracting data using ${modelName}...`, 'loading');
    
    try {
      const res = await fetch('/api/documents/verify', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          documentId: inlineDocument.id,
          pageNumber: pdfPageNumber,
          existingLots: tableData,
          correctionHistory: correctionHistory.slice(-20),
          capturedImage: capturedImage,
          model: selectedModel
        })
      });
      
      if (!res.ok) {
        const err = await res.text();
        log(`Extraction failed: ${err}`, 'error');
        return;
      }
      
      verificationResult = await res.json();
      showVerificationModal = true;
      
      const usedModel = verificationResult.usedModel || modelName;
      log(`Extracted ${verificationResult.lotsFound?.length || 0} lots using ${usedModel}`, 'success');
    } catch (e) {
      log(`Extraction error: ${e}`, 'error');
    } finally {
      analyzingPage = false;
    }
  }
  
  // Submit calibration and get final corrected results
  async function submitCalibration() {
    isCalibrating = true;
    log('Applying calibration and re-analyzing...', 'loading');
    
    // Build calibration feedback from user edits
    const calibrationFeedback = calibrationSamples.map(sample => ({
      lotNumber: sample.lotNumber,
      aiValues: {
        area: sample.area,
        frontage: sample.frontage,
        depth: sample.depth,
        streetName: sample.streetName
      },
      userValues: {
        area: sample.userArea,
        frontage: sample.userFrontage,
        depth: sample.userDepth,
        streetName: sample.userStreetName
      },
      corrections: {
        area: sample.area !== sample.userArea,
        frontage: sample.frontage !== sample.userFrontage,
        depth: sample.depth !== sample.userDepth,
        streetName: sample.streetName !== sample.userStreetName
      }
    }));
    
    try {
      const res = await fetch('/api/documents/verify', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          documentId: calibrationDocId,
          pageNumber: calibrationPageNum,
          existingLots: tableData,
          correctionHistory: correctionHistory.slice(-20),
          capturedImage: capturedImage,
          phase: 'final',
          calibrationFeedback: calibrationFeedback
        })
      });
      
      if (!res.ok) {
        const err = await res.text();
        log(`Calibrated verification failed: ${err}`, 'error');
        return;
      }
      
      verificationResult = await res.json();
      showCalibrationModal = false;
      showVerificationModal = true;
      log(`Calibration complete. Found ${verificationResult.corrections?.length || 0} corrections`, 'success');
    } catch (e) {
      log(`Calibration error: ${e}`, 'error');
    } finally {
      isCalibrating = false;
    }
  }
  
  // Skip calibration and show raw results
  function skipCalibration() {
    verificationResult = pendingFullResults;
    showCalibrationModal = false;
    showVerificationModal = true;
    log('Showing uncalibrated results', 'info');
  }
  
  // Start visual box calibration wizard
  async function startBoxCalibration() {
    if (!inlineDocument) return;
    
    analyzingPage = true;
    log('Loading page for visual calibration...', 'loading');
    
    try {
      // Get the PDF page as an image for the canvas
      const res = await fetch('/api/documents/verify', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          documentId: inlineDocument.id,
          pageNumber: pdfPageNumber,
          existingLots: tableData,
          phase: 'calibration',
          returnImage: true // Request the base64 image back
        })
      });
      
      if (!res.ok) {
        log('Failed to load page for calibration', 'error');
        return;
      }
      
      const result = await res.json();
      
      if (result.lotsFound && result.lotsFound.length > 0) {
        // Pick up to 5 RANDOM lots spread across the dataset for better calibration
        const allLots = result.lotsFound;
        const sampleCount = Math.min(5, allLots.length);
        let samples: any[];
        
        if (allLots.length <= 5) {
          samples = [...allLots];
        } else {
          // Stratified random sampling - pick from different parts of the list
          const indices = new Set<number>();
          // Always include first and last for range coverage
          indices.add(0);
          indices.add(allLots.length - 1);
          // Fill remaining with random picks from middle
          while (indices.size < sampleCount) {
            const randomIndex = Math.floor(Math.random() * allLots.length);
            indices.add(randomIndex);
          }
          samples = Array.from(indices).sort((a, b) => a - b).map(i => allLots[i]);
        }
        
        boxCalibrationLots = samples.map((lot: any) => ({
          lotNumber: lot.lotNumber || '?',
          fields: [
            { name: 'Area', aiValue: lot.area || '', userValue: lot.area || '', box: null, confirmed: false },
            { name: 'Frontage', aiValue: lot.frontage || '', userValue: lot.frontage || '', box: null, confirmed: false },
            { name: 'Depth', aiValue: lot.depth || '', userValue: lot.depth || '', box: null, confirmed: false }
          ]
        }));
        
        boxCalibrationImage = result.imageBase64 ? `data:image/png;base64,${result.imageBase64}` : null;
        currentLotIndex = 0;
        currentFieldIndex = 0;
        currentBox = null;
        pendingFullResults = result;
        calibrationDocId = inlineDocument.id;
        calibrationPageNum = pdfPageNumber;
        showBoxCalibration = true;
        
        log(`Visual calibration: ${boxCalibrationLots.length} lots to verify`, 'info');
      } else {
        log('No lots found on this page', 'error');
      }
    } catch (e) {
      log(`Calibration error: ${e}`, 'error');
    } finally {
      analyzingPage = false;
    }
  }
  
  // Get current lot and field being calibrated
  $: currentCalibrationLot = boxCalibrationLots[currentLotIndex];
  $: currentCalibrationField = currentCalibrationLot?.fields[currentFieldIndex];
  
  // Canvas mouse handlers for box drawing
  function handleCanvasMouseDown(e: MouseEvent) {
    if (!boxCanvasRef) return;
    const rect = boxCanvasRef.getBoundingClientRect();
    const scaleX = boxCanvasRef.width / rect.width;
    const scaleY = boxCanvasRef.height / rect.height;
    
    drawStartPos = {
      x: (e.clientX - rect.left) * scaleX,
      y: (e.clientY - rect.top) * scaleY
    };
    isDrawingBox = true;
  }
  
  function handleCanvasMouseMove(e: MouseEvent) {
    if (!isDrawingBox || !boxCanvasRef) return;
    const rect = boxCanvasRef.getBoundingClientRect();
    const scaleX = boxCanvasRef.width / rect.width;
    const scaleY = boxCanvasRef.height / rect.height;
    
    const currentX = (e.clientX - rect.left) * scaleX;
    const currentY = (e.clientY - rect.top) * scaleY;
    
    currentBox = {
      x: Math.min(drawStartPos.x, currentX),
      y: Math.min(drawStartPos.y, currentY),
      width: Math.abs(currentX - drawStartPos.x),
      height: Math.abs(currentY - drawStartPos.y)
    };
    
    redrawCanvas();
  }
  
  function handleCanvasMouseUp() {
    isDrawingBox = false;
    if (currentBox && currentBox.width > 10 && currentBox.height > 10) {
      // Save the box to current field
      if (currentCalibrationField) {
        currentCalibrationField.box = { ...currentBox };
        boxCalibrationLots = [...boxCalibrationLots]; // Trigger reactivity
        
        // Extract the boxed region and OCR it
        extractBoxRegion(currentBox);
      }
    }
  }
  
  // Extract text from the drawn box region using AI
  let isExtractingBox = false;
  async function extractBoxRegion(box: { x: number; y: number; width: number; height: number }) {
    if (!boxCanvasRef || !boxImageRef || !currentCalibrationField) return;
    
    isExtractingBox = true;
    
    try {
      // Create a temporary canvas to extract just the box region
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = box.width;
      tempCanvas.height = box.height;
      const tempCtx = tempCanvas.getContext('2d');
      if (!tempCtx) return;
      
      // Draw just the selected region
      tempCtx.drawImage(
        boxImageRef,
        box.x, box.y, box.width, box.height,  // Source region
        0, 0, box.width, box.height            // Destination
      );
      
      // Convert to base64
      const regionBase64 = tempCanvas.toDataURL('image/png').split(',')[1];
      
      // Send to AI for OCR
      const fieldName = currentCalibrationField.name.toLowerCase();
      const res = await fetch('/api/documents/ocr-region', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          imageBase64: regionBase64,
          fieldType: fieldName  // area, frontage, or depth
        })
      });
      
      if (res.ok) {
        const result = await res.json();
        if (result.value) {
          // Update the user value with OCR result
          currentCalibrationField.userValue = result.value;
          boxCalibrationLots = [...boxCalibrationLots]; // Trigger reactivity
          log(`OCR detected: ${result.value}`, 'success');
        }
      }
    } catch (e) {
      console.error('OCR extraction error:', e);
    } finally {
      isExtractingBox = false;
    }
  }
  
  function redrawCanvas() {
    if (!boxCanvasRef || !boxImageRef) return;
    const ctx = boxCanvasRef.getContext('2d');
    if (!ctx) return;
    
    // Draw the image
    ctx.drawImage(boxImageRef, 0, 0, boxCanvasRef.width, boxCanvasRef.height);
    
    // Draw current box being drawn
    if (currentBox) {
      ctx.strokeStyle = '#7aa2f7';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.strokeRect(currentBox.x, currentBox.y, currentBox.width, currentBox.height);
      ctx.setLineDash([]);
    }
    
    // Draw saved box for current field
    if (currentCalibrationField?.box) {
      ctx.strokeStyle = '#9ece6a';
      ctx.lineWidth = 3;
      ctx.strokeRect(
        currentCalibrationField.box.x,
        currentCalibrationField.box.y,
        currentCalibrationField.box.width,
        currentCalibrationField.box.height
      );
      
      // Label
      ctx.fillStyle = '#9ece6a';
      ctx.font = 'bold 14px monospace';
      ctx.fillText(
        `${currentCalibrationField.name}: ${currentCalibrationField.userValue}`,
        currentCalibrationField.box.x + 5,
        currentCalibrationField.box.y - 5
      );
    }
  }
  
  // Initialize canvas when image loads
  function onCalibrationImageLoad(e: Event) {
    const img = e.target as HTMLImageElement;
    boxImageRef = img;
    
    if (boxCanvasRef) {
      boxCanvasRef.width = img.naturalWidth;
      boxCanvasRef.height = img.naturalHeight;
      redrawCanvas();
    }
  }
  
  // Confirm current field and move to next
  function confirmField() {
    if (currentCalibrationField) {
      currentCalibrationField.confirmed = true;
      boxCalibrationLots = [...boxCalibrationLots];
    }
    nextField();
  }
  
  // Move to next field or lot
  function nextField() {
    if (currentFieldIndex < 2) {
      currentFieldIndex++;
    } else if (currentLotIndex < boxCalibrationLots.length - 1) {
      currentLotIndex++;
      currentFieldIndex = 0;
    }
    currentBox = null;
    redrawCanvas();
  }
  
  // Move to previous field or lot
  function prevField() {
    if (currentFieldIndex > 0) {
      currentFieldIndex--;
    } else if (currentLotIndex > 0) {
      currentLotIndex--;
      currentFieldIndex = 2;
    }
    currentBox = null;
    redrawCanvas();
  }
  
  // Complete visual calibration and submit
  async function submitBoxCalibration() {
    isCalibrating = true;
    log('Applying visual calibration...', 'loading');
    
    // Build calibration data from boxes
    const boxFeedback = boxCalibrationLots.map(lot => ({
      lotNumber: lot.lotNumber,
      fields: lot.fields.map(f => ({
        name: f.name.toLowerCase(),
        aiValue: f.aiValue,
        userValue: f.userValue,
        hasBox: !!f.box,
        confirmed: f.confirmed
      }))
    }));
    
    try {
      const res = await fetch('/api/documents/verify', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          documentId: calibrationDocId || inlineDocument?.id,
          pageNumber: calibrationPageNum || pdfPageNumber,
          existingLots: tableData,
          phase: 'final',
          boxCalibrationFeedback: boxFeedback
        })
      });
      
      if (!res.ok) {
        log('Calibration failed', 'error');
        return;
      }
      
      verificationResult = await res.json();
      showBoxCalibration = false;
      showVerificationModal = true;
      log(`Visual calibration complete. Found ${verificationResult.corrections?.length || 0} corrections`, 'success');
    } catch (e) {
      log(`Error: ${e}`, 'error');
    } finally {
      isCalibrating = false;
    }
  }
  
  // Apply a single correction from verification
  async function applyCorrection(correction: any) {
    const { lotId, field, newValue } = correction;
    
    try {
      const res = await fetch('/api/lots', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id: lotId, [field]: newValue })
      });
      
      if (res.ok) {
        log(`Updated lot ${correction.lotNumber} ${field}`, 'success');
        // Remove from corrections list
        verificationResult.corrections = verificationResult.corrections.filter(
          (c: any) => !(c.lotId === lotId && c.field === field)
        );
        // Refresh table
        if (selectedNode) {
          const config = typeConfig[selectedNode.type];
          if (config.childEndpoint) {
            const res = await fetch(`${config.childEndpoint}?${config.childKey}=${selectedNode.id}`);
            tableData = await res.json();
          }
        }
      }
    } catch (e) {
      log(`Failed to apply correction: ${e}`, 'error');
    }
  }
  
  // Apply all corrections from verification
  async function applyAllCorrections() {
    if (!verificationResult?.corrections) return;
    
    log(`Applying ${verificationResult.corrections.length} corrections...`, 'loading');
    let applied = 0;
    
    for (const correction of [...verificationResult.corrections]) {
      await applyCorrection(correction);
      applied++;
    }
    
    log(`Applied ${applied} corrections`, 'success');
    showVerificationModal = false;
  }
  
  // Capture screen/window for AI analysis
  async function captureScreen() {
    isCapturing = true;
    log('Starting screen capture...', 'loading');
    
    try {
      // Request screen capture permission
      const stream = await navigator.mediaDevices.getDisplayMedia({
        video: { displaySurface: 'window' } as any,
        audio: false
      });
      
      // Get video track and capture frame
      const track = stream.getVideoTracks()[0];
      const imageCapture = new (window as any).ImageCapture(track);
      const bitmap = await imageCapture.grabFrame();
      
      // Convert to canvas and base64
      const canvas = document.createElement('canvas');
      canvas.width = bitmap.width;
      canvas.height = bitmap.height;
      const ctx = canvas.getContext('2d');
      ctx?.drawImage(bitmap, 0, 0);
      
      // Get base64 image (without data URL prefix for API)
      const dataUrl = canvas.toDataURL('image/png');
      capturedImage = dataUrl.split(',')[1];
      
      // Stop the stream
      track.stop();
      
      log('Screen captured! Click "Verify Data" to analyze.', 'success');
    } catch (e: any) {
      if (e.name === 'NotAllowedError') {
        log('Screen capture cancelled', 'info');
      } else {
        log(`Capture failed: ${e.message}`, 'error');
      }
      capturedImage = null;
    } finally {
      isCapturing = false;
    }
  }
  
  // Clear captured image
  function clearCapture() {
    capturedImage = null;
    log('Capture cleared', 'info');
  }
  
  function startEdit(row: any) {
    editingId = row.id;
    editValues = {
      name: row.name || row.lotNumber || row.invoiceNumber || '',
      detail: row.description || row.status || row.address || '',
      area: row.area || '',
      frontage: row.frontage || '',
      depth: row.depth || '',
      streetName: row.streetName || '',
      price: row.price || '',
      status: row.status || '',
      // Handle registrationDate - convert ISO to YYYY-MM-DD for date input
      registrationDate: row.registrationDate ? new Date(row.registrationDate).toISOString().split('T')[0] : ''
    };
    // Load custom field values
    for (const field of customFields) {
      editValues[field.fieldKey] = getCustomFieldValue(row, field.fieldKey);
    }
  }
  
  function cancelEdit() {
    editingId = null;
    editValues = {};
  }
  
  async function saveEdit(row: any) {
    if (!selectedNode || savingRow) return;
    savingRow = true;
    const config = typeConfig[selectedNode.type];
    
    const updateData: any = { id: row.id };
    if (row.name !== undefined) updateData.name = editValues.name;
    else if (row.lotNumber !== undefined) updateData.lotNumber = editValues.name;
    else if (row.invoiceNumber !== undefined) updateData.invoiceNumber = editValues.name;
    
    if (row.description !== undefined) updateData.description = editValues.detail;
    else if (row.status !== undefined) updateData.status = editValues.detail;
    else if (row.address !== undefined) updateData.address = editValues.detail;
    
    // Handle lot-specific fields and track corrections for AI learning
    if (selectedNode.type === 'stage') {
      const lotNumber = row.lotNumber || editValues.name;
      
      // Track corrections for AI learning
      if (editValues.area !== (row.area || '') && editValues.area) {
        correctionHistory.push({ lotNumber, field: 'area', oldValue: row.area || '', newValue: editValues.area, timestamp: new Date() });
      }
      if (editValues.frontage !== (row.frontage || '') && editValues.frontage) {
        correctionHistory.push({ lotNumber, field: 'frontage', oldValue: row.frontage || '', newValue: editValues.frontage, timestamp: new Date() });
      }
      if (editValues.depth !== (row.depth || '') && editValues.depth) {
        correctionHistory.push({ lotNumber, field: 'depth', oldValue: row.depth || '', newValue: editValues.depth, timestamp: new Date() });
      }
      if (editValues.streetName !== (row.streetName || '') && editValues.streetName) {
        correctionHistory.push({ lotNumber, field: 'streetName', oldValue: row.streetName || '', newValue: editValues.streetName, timestamp: new Date() });
      }
      
      // Keep only last 50 corrections
      if (correctionHistory.length > 50) {
        correctionHistory = correctionHistory.slice(-50);
      }
      
      updateData.area = editValues.area || null;
      updateData.frontage = editValues.frontage || null;
      updateData.depth = editValues.depth || null;
      updateData.streetName = editValues.streetName || null;
      updateData.status = editValues.status || null;
      
      // Save price if provided
      if (editValues.price !== undefined && editValues.price !== '') {
        const priceValue = parseFloat(String(editValues.price).replace(/,/g, '')) || 0;
        updateData.price = priceValue;
        const area = parseFloat(editValues.area) || parseFloat(row.area) || 0;
        updateData.pricePerSqm = area > 0 ? Math.round(priceValue / area) : 0;
      }
    }
    
    // Handle registrationDate for stages when editing from precinct table
    if (selectedNode.type === 'precinct' && editValues.registrationDate !== undefined) {
      updateData.registrationDate = editValues.registrationDate ? new Date(editValues.registrationDate).toISOString() : null;
    }
    
    // Build customData from custom fields
    if (customFields.length > 0) {
      const existingCustomData = row.customData ? 
        (typeof row.customData === 'string' ? JSON.parse(row.customData) : row.customData) : {};
      for (const field of customFields) {
        if (editValues[field.fieldKey] !== undefined) {
          existingCustomData[field.fieldKey] = editValues[field.fieldKey];
        }
      }
      updateData.customData = JSON.stringify(existingCustomData);
    }
    
    try {
      const res = await fetch(config.childEndpoint, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updateData)
      });
      if (res.ok) {
        Object.assign(row, updateData);
        tableData = [...tableData];
        log('Updated successfully', 'success');
      } else {
        log('Update failed', 'error');
      }
    } catch (e) {
      log('Update error', 'error');
    } finally {
      savingRow = false;
    }
    editingId = null;
  }
  
  async function deleteRow(row: any) {
    if (!selectedNode || deletingRow !== null) return;
    deletingRow = row.id;
    const config = typeConfig[selectedNode.type];
    
    try {
      const res = await fetch(config.childEndpoint, {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id: row.id })
      });
      if (res.ok) {
        tableData = tableData.filter(r => r.id !== row.id);
        log('Deleted successfully', 'success');
      } else {
        log('Delete failed', 'error');
      }
    } catch (e) {
      log('Delete error', 'error');
    } finally {
      deletingRow = null;
    }
  }
  
  function startAdd() {
    isAdding = true;
    newRowValues = { name: '', detail: '' };
  }
  
  function cancelAdd() {
    isAdding = false;
    newRowValues = {};
  }
  
  async function saveAdd() {
    if (!selectedNode || savingAdd) return;
    savingAdd = true;
    const config = typeConfig[selectedNode.type];
    
    const newData: any = { [config.childKey]: selectedNode.id };
    
    if (config.childType === 'lot') {
      newData.lotNumber = newRowValues.name;
      newData.address = newRowValues.detail;
      newData.area = newRowValues.area || null;
      newData.frontage = newRowValues.frontage || null;
      newData.depth = newRowValues.depth || null;
      newData.streetName = newRowValues.streetName || null;
    } else if (config.childType === 'invoice') {
      newData.invoiceNumber = newRowValues.name;
      newData.status = newRowValues.detail;
    } else {
      newData.name = newRowValues.name;
      newData.description = newRowValues.detail;
    }
    
    try {
      const res = await fetch(config.childEndpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newData)
      });
      if (res.ok) {
        const created = await res.json();
        tableData = [created, ...tableData];
        // Also add to tree if parent is expanded
        if (selectedNode && selectedNode.expanded && selectedNode.children) {
          const newTreeNode: TreeNode = {
            id: created.id,
            name: created.name || created.lotNumber || `#${created.id}`,
            type: config.childType,
            parentId: selectedNode.id
          };
          selectedNode.children = [newTreeNode, ...selectedNode.children];
          tree = [...tree];
        }
        log('Created successfully', 'success');
      } else {
        log('Create failed', 'error');
      }
    } catch (e) {
      log('Create error', 'error');
    } finally {
      savingAdd = false;
    }
    isAdding = false;
    newRowValues = {};
  }
  
  function renderTree(nodes: TreeNode[], depth = 0, isLast: boolean[] = []): string {
    let result = '';
    nodes.forEach((node, i) => {
      const last = i === nodes.length - 1;
      const prefix = isLast.map(l => l ? '   ' : 'â  ').join('');
      const branch = last ? 'ââ ' : 'ââ ';
      const expandIcon = node.loading ? '*' : (node.children?.length ? (node.expanded ? 'â¼' : 'â¶') : ' ');
      result += `${prefix}${branch}${expandIcon} [${typeLabels[node.type]}] ${node.name}\n`;
      if (node.expanded && node.children) {
        result += renderTree(node.children, depth + 1, [...isLast, last]);
      }
    });
    return result;
  }
</script>

{#snippet treeNode(node: TreeNode, depth: number, isLast: boolean, ancestors: boolean[])}
  {@const hasChildren = typeConfig[node.type].childEndpoint !== ''}
  <div class="tree-row" class:selected={selectedNode?.id === node.id && selectedNode?.type === node.type}>
    <span class="tree-prefix">{#each ancestors as showLine}{#if showLine}â{:else}&nbsp;{/if}&nbsp;&nbsp;{/each}{#if isLast}ââ{:else}ââ{/if}&nbsp;</span>
    <button class="tree-expand" on:click={() => toggleNode(node)} disabled={!hasChildren}>
      {#if node.loading}*{:else if hasChildren}{node.expanded ? 'â¼' : 'â¶'}{:else}Â·{/if}
    </button>
    <button class="tree-label" style="color: {typeColors[node.type]}" on:click={() => selectNode(node)}>
      [{typeLabels[node.type]}] {node.name}
    </button>
  </div>
  {#if node.expanded && node.children}
    {#each node.children as child, i}
      {@render treeNode(child, depth + 1, i === node.children.length - 1, [...ancestors, !isLast])}
    {/each}
  {/if}
{/snippet}

{#if authLoading}
  <div class="auth-loading">
    <div class="loading-spinner"></div>
    <span>Loading...</span>
  </div>
{:else if currentUser}
<div class="app">
  <AuthHeader
    {currentUser}
    version={__VERSION__}
    {isAdmin}
    {canManageUsers}
    {userPrimaryRole}
    {userCanView}
    {userCanEdit}
    {userCanDelete}
    onOpenUserManagement={() => showUserManagement = true}
    onLogout={logout}
  />
  
  <div class="main">
    <div class="tree-panel" class:collapsed={treeNavCollapsed}>
      <div class="panel-header tree-header">
        <button class="tree-toggle-btn" on:click={() => treeNavCollapsed = !treeNavCollapsed} title={treeNavCollapsed ? 'Expand Tree' : 'Collapse Tree'}>
          {treeNavCollapsed ? 'â¶' : 'â¼'}
        </button>
        <span>ââ Tree Navigation</span>
        <button class="add-company-btn" on:click={() => showNewCompanyModal = true} title="Create New Company Group">
          + New Group
        </button>
      </div>
      <div class="tree-content" class:hidden={treeNavCollapsed}>
        {#if tree.length === 0}
          <div class="empty-tree">
            <p>No Company Groups yet</p>
            <button class="btn-primary" on:click={() => showNewCompanyModal = true}>
              Create Your First Company Group
            </button>
          </div>
        {:else}
          {#each tree as node, i}
            {@render treeNode(node, 0, i === tree.length - 1, [])}
          {/each}
        {/if}
      </div>
    </div>
    
    <div class="table-panel">
      <div class="table-panel-scroll">
      {#if selectedNode}
        {#if hierarchyPath.length > 1}
          <div class="hierarchy-path">
            <span class="path-label">ââ Path:</span>
            {#each hierarchyPath as item, i}
              {#if i > 0}<span class="path-sep">â</span>{/if}
              <span class="path-item" style="color: {typeColors[item.type]}">[{typeLabels[item.type]}] {item.name}</span>
            {/each}
          </div>
        {/if}
        
        {#if entityDetails}
        <PropertiesPanel
          {selectedNode}
          {entityDetails}
          {entityFields}
          {typeLabels}
          collapsed={!showProperties}
          hasPermission={hasPermission}
          onToggleCollapsed={() => { showProperties = !showProperties; if (selectedNode) saveNodePreference(selectedNode.type, selectedNode.id, 'showProperties', showProperties); }}
          onSave={handlePropertySave}
        />
        {/if}
        
        <PricingPanel
          {selectedNode}
          bind:pricingProducts
          masterplanCount={tableData.filter(lot => lot.status?.toLowerCase() === 'masterplan' && (!lot.price || lot.price === 0)).length}
          hasPermission={hasPermission}
          onLog={log}
          onApplyToMasterplan={applyPricingToMasterplanLots}
        />
        
        <DocumentPanel
          {selectedNode}
          {documents}
          tableDataLength={tableData.length}
          {extractingDocId}
          {selectedModel}
          hasPermission={hasPermission}
          onUpload={handleDocumentUpload}
          onDelete={deleteDocument}
          onExtract={(docId) => extractFromDocument(docId, false)}
          onReanalyze={(docId) => extractFromDocument(docId, true)}
          onAnalyzePOS={analyzePlanOfSubdivision}
          onCrossReference={crossReferenceDocument}
          onOpenPreExtraction={openPreExtractionModal}
          onPreview={(doc) => previewDocument = doc}
          onModelChange={(model) => { selectedModel = model as any; }}
        />
      {/if}
      
      {#if inlineDocument}
        <div class="inline-viewer-section">
          <div class="inline-viewer-header">
            <span>{inlineDocument.mimeType === 'application/pdf' ? 'ð' : 'ð'} {inlineDocument.originalName}</span>
            <div class="inline-viewer-controls">
              {#if inlineDocument.mimeType?.startsWith('image/')}
                <button class="zoom-btn" on:click={() => inlineZoom = Math.max(0.5, inlineZoom - 0.25)}>ðâ</button>
                <span class="zoom-level">{Math.round(inlineZoom * 100)}%</span>
                <button class="zoom-btn" on:click={() => inlineZoom = Math.min(3, inlineZoom + 0.25)}>ð+</button>
                <button class="zoom-btn" on:click={() => inlineZoom = 1}>Reset</button>
              {/if}
              {#if inlineDocument.mimeType === 'application/pdf'}
                <div class="page-controls">
                  <button class="page-btn" on:click={() => pdfPageNumber = Math.max(1, pdfPageNumber - 1)} title="Previous page">â</button>
                  <span class="page-indicator">Page {pdfPageNumber}</span>
                  <button class="page-btn" on:click={() => pdfPageNumber++} title="Next page">â¶</button>
                </div>
              {/if}
              <button 
                class="btn-capture" 
                on:click={captureScreen}
                disabled={isCapturing}
                title="Capture your screen view for AI analysis"
              >
                {isCapturing ? 'â³' : 'ð·'} {capturedImage ? 'Re-capture' : 'Capture'}
              </button>
              {#if capturedImage}
                <span class="capture-indicator" title="Screen capture ready">â</span>
                <button class="btn-clear-capture" on:click={clearCapture} title="Clear capture">â</button>
              {/if}
              <select 
                class="model-selector" 
                bind:value={selectedModel}
                title="Choose AI model for extraction"
              >
                {#each modelOptions as model}
                  <option value={model.id}>{model.name}</option>
                {/each}
              </select>
              <button 
                class="btn-analyze-page" 
                on:click={analyzePageForVerification}
                disabled={analyzingPage || (!capturedImage && inlineDocument.mimeType !== 'application/pdf')}
                title={capturedImage ? "Analyze captured screen" : "Analyze PDF page and verify lot data"}
              >
                {analyzingPage ? 'â³' : 'ð'} Extract Data
              </button>
              <input type="range" min="150" max="500" bind:value={inlineViewerHeight} class="height-slider" title="Adjust viewer height" />
              <button class="btn-close-inline" on:click={() => inlineDocument = null}>â</button>
            </div>
          </div>
          <div class="inline-viewer-container" style="height: {inlineViewerHeight}px;">
            {#if inlineDocument.mimeType === 'application/pdf'}
              <iframe 
                src="{inlineDocument.filename}" 
                title={inlineDocument.originalName}
                class="inline-viewer-pdf"
              ></iframe>
            {:else}
              <div class="inline-viewer-scroll">
                <img 
                  src="{inlineDocument.filename}" 
                  alt={inlineDocument.originalName} 
                  class="inline-viewer-image"
                  style="transform: scale({inlineZoom}); transform-origin: top left;"
                />
              </div>
            {/if}
          </div>
        </div>
      {/if}
      
      <SummaryBar
        {tableData}
        summary={tableSummary}
        collapsed={!showSummary}
        {pricingProducts}
        {calculateLotPrice}
        onToggleCollapsed={() => { showSummary = !showSummary; if (selectedNode) saveNodePreference(selectedNode.type, selectedNode.id, 'showSummary', showSummary); }}
        onStartPricingReview={startPricingReview}
        onApplyPricing={applyPricingToMasterplanLots}
      />
      
      <LandBudgetPanel
        {selectedNode}
        userCanEdit={userCanEdit}
        onLog={log}
      />
      
      <ForecastPanel
        {selectedNode}
        onLog={log}
        onSaveNodePreference={saveNodePreference}
        onLoadNodePreferences={loadNodePreferences}
      />
      <!-- STAGE TABLE - Separate Section -->
      <div class="stage-table-section">
        <div class="panel-header collapsible" on:click={() => showStageTable = !showStageTable} on:keydown={(e) => e.key === 'Enter' && (showStageTable = !showStageTable)} role="button" tabindex="0">
          <span>ââ {showStageTable ? 'â¼' : 'â¶'} {selectedNode ? `${typeLabels[selectedNode.type]} ${selectedNode.name}` : 'Select item'} â Children {tableData.length > 0 ? `(${tableData.length})` : ''}</span>
          <div class="panel-header-actions" on:click|stopPropagation on:keydown|stopPropagation>
            {#if selectedNode?.type === 'stage' && tableData.length > 0}
              {#if stageTableTab === 'main'}
                {#if inlinePriceEditMode}
                  <span class="edit-mode-badge">Editing Prices</span>
                {:else}
                  <button class="btn-edit-all-prices" on:click={startInlinePriceEdit}>
                    ð° Edit Prices
                  </button>
                {/if}
              {:else if stageTableTab === 'dates'}
                {#if datesTabEditMode}
                  <span class="edit-mode-badge">Editing Dates</span>
                  <button class="btn-cancel-tab" on:click={cancelDatesTabEdit}>Cancel</button>
                  <button class="btn-save-tab" on:click={saveDatesTabEdits}>â Save All</button>
                {:else}
                  <button class="btn-tab-action" on:click={startDatesTabEdit}>
                    âï¸ Edit Dates
                  </button>
                {/if}
              {:else if stageTableTab === 'pricing'}
                {#if pricingTabEditMode}
                  <span class="edit-mode-badge">Editing Pricing</span>
                  <button class="btn-cancel-tab" on:click={cancelPricingTabEdit}>Cancel</button>
                  <button class="btn-save-tab" on:click={savePricingTabEdits}>â Save All</button>
                {:else}
                  <button class="btn-tab-action" on:click={startPricingTabEdit}>
                    âï¸ Edit Pricing
                  </button>
                {/if}
              {/if}
            {/if}
            {#if selectedNode && typeConfig[selectedNode.type].childEndpoint && stageTableTab === 'main' && userCanEdit}
              <button class="add-btn" on:click={startAdd} disabled={isAdding}>+ Add</button>
            {/if}
          </div>
        </div>
      </div>
      
      {#if showStageTable}
      {#if selectedNode?.type === 'stage' && tableData.length > 0}
        <div class="stage-table-tabs">
          <button 
            class="stage-tab" 
            class:active={stageTableTab === 'main'}
            on:click={() => stageTableTab = 'main'}
          >
            ð Main
          </button>
          <button 
            class="stage-tab" 
            class:active={stageTableTab === 'dates'}
            on:click={() => stageTableTab = 'dates'}
          >
            ð Key Dates
          </button>
          <button 
            class="stage-tab" 
            class:active={stageTableTab === 'pricing'}
            on:click={() => stageTableTab = 'pricing'}
          >
            ðµ Pricing Details
          </button>
        </div>
      {/if}
      
      {#if inlinePriceEditMode}
        <div class="inline-price-edit-bar">
          <span class="edit-info">ð° Editing prices for {tableData.length} lots</span>
          <button 
            class="btn-apply-all-suggested" 
            on:click={applyAllSuggestedPrices}
            disabled={pricingProducts.filter(p => p.basePrice > 0).length === 0}
            title="Apply suggested pricing from matrix to all lots"
          >
            ð Use All Suggested
          </button>
          <span class="change-count">{inlinePriceChangeCount} changes pending</span>
          <div class="edit-actions">
            <button class="btn-cancel-edit" on:click={cancelInlinePriceEdit}>Cancel</button>
            <button 
              class="btn-save-all-prices" 
              on:click={saveAllInlinePrices} 
              disabled={inlinePriceChangeCount === 0 || savingAllPrices}
            >
              {#if savingAllPrices}
                Saving...
              {:else}
                â Save All ({inlinePriceChangeCount})
              {/if}
            </button>
          </div>
        </div>
      {/if}
      
      {#if selectedRows.size > 0}
        <div class="bulk-edit-bar">
          <span class="bulk-selected">{selectedRows.size} selected</span>
          <select bind:value={bulkEditField} class="bulk-field-select">
            <option value="">Select field...</option>
            {#if selectedNode?.type === 'stage' && stageTableTab === 'main'}
              <option value="streetName">Street Name</option>
              <option value="area">Area</option>
              <option value="frontage">Frontage</option>
              <option value="depth">Depth</option>
              <option value="status">Status</option>
            {:else if selectedNode?.type === 'stage' && stageTableTab === 'dates'}
              <option value="on_market_date">On Market Date</option>
              <option value="sold_date">Sold Date</option>
              <option value="exchange_date">Exchange Date</option>
              <option value="settled_date">Settled Date</option>
              <option value="cancelled_date">Cancelled Date</option>
            {:else if selectedNode?.type === 'stage' && stageTableTab === 'pricing'}
              <option value="deposit_amount">Deposit Amount</option>
              <option value="deposit_date">Deposit Date</option>
              <option value="rebates">Rebates</option>
              <option value="discounts">Discounts</option>
              <option value="price_adjustments">Price Adjustments</option>
            {:else}
              <option value="name">Name</option>
              <option value="description">Description</option>
            {/if}
          </select>
          {#if stageTableTab === 'dates' || (stageTableTab === 'pricing' && bulkEditField === 'deposit_date')}
            <input type="date" bind:value={bulkEditValue} class="bulk-value-input" />
          {:else}
            <input type="text" bind:value={bulkEditValue} placeholder="New value..." class="bulk-value-input" />
          {/if}
          <button class="btn-bulk-apply" on:click={() => stageTableTab === 'main' ? applyBulkEdit() : applyBulkCustomFieldEdit()} disabled={!bulkEditField || !bulkEditValue}>
            Apply to {selectedRows.size}
          </button>
          <button class="btn-bulk-clear" on:click={clearSelection}>Clear</button>
        </div>
      {/if}
      
      <div class="table-content">
        {#if loading}
          <div class="loading-msg">Loading...</div>
        {:else if !selectedNode}
          <div class="empty-msg">â Select an item from the tree</div>
        {:else if tableData.length === 0 && !isAdding}
          <div class="empty-msg">No children found. Click + Add to create one.</div>
        {:else if selectedNode?.type === 'stage' && stageTableTab === 'dates'}
          <!-- Key Dates Tab -->
          <div class="table-scroll-wrapper">
            <table class="data-table dates-table">
              <thead>
                <tr>
                  <th class="th-checkbox">
                    <input type="checkbox" checked={selectedRows.size === tableData.length && tableData.length > 0} on:change={toggleAllRows} title="Select all" />
                  </th>
                  <th class="th-id">ID</th>
                  <th class="th-field">Lot #</th>
                  <th class="th-field">Status</th>
                  <th class="th-field th-date">On Market</th>
                  <th class="th-field th-date">Sold Date</th>
                  <th class="th-field th-date">Exchange Date</th>
                  <th class="th-field th-date">Settled Date</th>
                  <th class="th-field th-date">Cancelled Date</th>
                </tr>
              </thead>
              <tbody>
                {#each sortedTableData as row}
                  {@const customData = row.customData ? (typeof row.customData === 'string' ? JSON.parse(row.customData) : row.customData) : {}}
                  {@const rowEdits = datesTabEdits.get(row.id) || {}}
                  <tr class:selected={selectedRows.has(row.id)}>
                    <td class="checkbox-col">
                      <input type="checkbox" checked={selectedRows.has(row.id)} on:change={() => toggleRowSelection(row.id)} />
                    </td>
                    <td class="id-col">{row.id}</td>
                    <td class="field-col">{row.lotNumber || '-'}</td>
                    <td class="field-col status-col">
                      <span class="status-badge status-{(row.status || '').toLowerCase().replace(/\s+/g, '-')}">{row.status || '-'}</span>
                    </td>
                    <td class="field-col date-col">
                      {#if datesTabEditMode}
                        <input type="date" value={rowEdits.on_market_date || ''} on:input={(e) => { rowEdits.on_market_date = e.currentTarget.value; datesTabEdits = datesTabEdits; }} class="date-input-cell" />
                      {:else}
                        {@const status = getDateStatus(customData.on_market_date, customData.on_market_date_actual)}
                        <div class="date-with-status">
                          <span class="date-display">{customData.on_market_date || '-'}</span>
                          {#if status !== 'none'}
                            <button 
                              class="date-status-badge" 
                              style="background: {dateStatusStyles[status].bg}; color: {dateStatusStyles[status].color}; border-color: {dateStatusStyles[status].border};"
                              title="{dateStatusStyles[status].title} - Click to {status === 'actual' ? 'revert' : 'confirm'}"
                              on:click={() => toggleLotDateActual(row.id, 'on_market_date', customData)}
                            >{dateStatusStyles[status].label}</button>
                          {/if}
                        </div>
                      {/if}
                    </td>
                    <td class="field-col date-col">
                      {#if datesTabEditMode}
                        <input type="date" value={rowEdits.sold_date || ''} on:input={(e) => { rowEdits.sold_date = e.currentTarget.value; datesTabEdits = datesTabEdits; }} class="date-input-cell" />
                      {:else}
                        {@const status = getDateStatus(customData.sold_date, customData.sold_date_actual)}
                        <div class="date-with-status">
                          <span class="date-display">{customData.sold_date || '-'}</span>
                          {#if status !== 'none'}
                            <button 
                              class="date-status-badge" 
                              style="background: {dateStatusStyles[status].bg}; color: {dateStatusStyles[status].color}; border-color: {dateStatusStyles[status].border};"
                              title="{dateStatusStyles[status].title} - Click to {status === 'actual' ? 'revert' : 'confirm'}"
                              on:click={() => toggleLotDateActual(row.id, 'sold_date', customData)}
                            >{dateStatusStyles[status].label}</button>
                          {/if}
                        </div>
                      {/if}
                    </td>
                    <td class="field-col date-col">
                      {#if datesTabEditMode}
                        <input type="date" value={rowEdits.exchange_date || ''} on:input={(e) => { rowEdits.exchange_date = e.currentTarget.value; datesTabEdits = datesTabEdits; }} class="date-input-cell" />
                      {:else}
                        {@const status = getDateStatus(customData.exchange_date, customData.exchange_date_actual)}
                        <div class="date-with-status">
                          <span class="date-display">{customData.exchange_date || '-'}</span>
                          {#if status !== 'none'}
                            <button 
                              class="date-status-badge" 
                              style="background: {dateStatusStyles[status].bg}; color: {dateStatusStyles[status].color}; border-color: {dateStatusStyles[status].border};"
                              title="{dateStatusStyles[status].title} - Click to {status === 'actual' ? 'revert' : 'confirm'}"
                              on:click={() => toggleLotDateActual(row.id, 'exchange_date', customData)}
                            >{dateStatusStyles[status].label}</button>
                          {/if}
                        </div>
                      {/if}
                    </td>
                    <td class="field-col date-col">
                      {#if datesTabEditMode}
                        <input type="date" value={rowEdits.settled_date || ''} on:input={(e) => { rowEdits.settled_date = e.currentTarget.value; datesTabEdits = datesTabEdits; }} class="date-input-cell" />
                      {:else}
                        {@const status = getDateStatus(customData.settled_date, customData.settled_date_actual)}
                        <div class="date-with-status">
                          <span class="date-display">{customData.settled_date || '-'}</span>
                          {#if status !== 'none'}
                            <button 
                              class="date-status-badge" 
                              style="background: {dateStatusStyles[status].bg}; color: {dateStatusStyles[status].color}; border-color: {dateStatusStyles[status].border};"
                              title="{dateStatusStyles[status].title} - Click to {status === 'actual' ? 'revert' : 'confirm'}"
                              on:click={() => toggleLotDateActual(row.id, 'settled_date', customData)}
                            >{dateStatusStyles[status].label}</button>
                          {/if}
                        </div>
                      {/if}
                    </td>
                    <td class="field-col date-col">
                      {#if datesTabEditMode}
                        <input type="date" value={rowEdits.cancelled_date || ''} on:input={(e) => { rowEdits.cancelled_date = e.currentTarget.value; datesTabEdits = datesTabEdits; }} class="date-input-cell" />
                      {:else}
                        {@const status = getDateStatus(customData.cancelled_date, customData.cancelled_date_actual)}
                        <div class="date-with-status">
                          <span class="date-display">{customData.cancelled_date || '-'}</span>
                          {#if status !== 'none'}
                            <button 
                              class="date-status-badge" 
                              style="background: {dateStatusStyles[status].bg}; color: {dateStatusStyles[status].color}; border-color: {dateStatusStyles[status].border};"
                              title="{dateStatusStyles[status].title} - Click to {status === 'actual' ? 'revert' : 'confirm'}"
                              on:click={() => toggleLotDateActual(row.id, 'cancelled_date', customData)}
                            >{dateStatusStyles[status].label}</button>
                          {/if}
                        </div>
                      {/if}
                    </td>
                  </tr>
                {/each}
              </tbody>
            </table>
          </div>
        {:else if selectedNode?.type === 'stage' && stageTableTab === 'pricing'}
          <!-- Pricing Details Tab -->
          <div class="table-scroll-wrapper">
            <table class="data-table pricing-details-table">
              <thead>
                <tr>
                  <th class="th-checkbox">
                    <input type="checkbox" checked={selectedRows.size === tableData.length && tableData.length > 0} on:change={toggleAllRows} title="Select all" />
                  </th>
                  <th class="th-id">ID</th>
                  <th class="th-field">Lot #</th>
                  <th class="th-field th-num">Price</th>
                  <th class="th-field th-num">Deposit Amt</th>
                  <th class="th-field th-date">Deposit Date</th>
                  <th class="th-field th-num">Rebates</th>
                  <th class="th-field th-num">Discounts</th>
                  <th class="th-field">Price Adjustments</th>
                </tr>
              </thead>
              <tbody>
                {#each sortedTableData as row}
                  {@const customData = row.customData ? (typeof row.customData === 'string' ? JSON.parse(row.customData) : row.customData) : {}}
                  {@const rowEdits = pricingTabEdits.get(row.id) || {}}
                  <tr class:selected={selectedRows.has(row.id)}>
                    <td class="checkbox-col">
                      <input type="checkbox" checked={selectedRows.has(row.id)} on:change={() => toggleRowSelection(row.id)} />
                    </td>
                    <td class="id-col">{row.id}</td>
                    <td class="field-col">{row.lotNumber || '-'}</td>
                    <td class="field-col num-col">{row.price ? `$${parseFloat(row.price).toLocaleString()}` : '-'}</td>
                    <td class="field-col num-col">
                      {#if pricingTabEditMode}
                        <input type="text" value={rowEdits.deposit_amount || ''} on:input={(e) => { rowEdits.deposit_amount = e.currentTarget.value; pricingTabEdits = pricingTabEdits; }} class="number-input-cell" placeholder="$0" />
                      {:else}
                        <span class="value-display">{customData.deposit_amount || '-'}</span>
                      {/if}
                    </td>
                    <td class="field-col date-col">
                      {#if pricingTabEditMode}
                        <input type="date" value={rowEdits.deposit_date || ''} on:input={(e) => { rowEdits.deposit_date = e.currentTarget.value; pricingTabEdits = pricingTabEdits; }} class="date-input-cell" />
                      {:else}
                        <span class="date-display">{customData.deposit_date || '-'}</span>
                      {/if}
                    </td>
                    <td class="field-col num-col">
                      {#if pricingTabEditMode}
                        <input type="text" value={rowEdits.rebates || ''} on:input={(e) => { rowEdits.rebates = e.currentTarget.value; pricingTabEdits = pricingTabEdits; }} class="number-input-cell" placeholder="$0" />
                      {:else}
                        <span class="value-display">{customData.rebates || '-'}</span>
                      {/if}
                    </td>
                    <td class="field-col num-col">
                      {#if pricingTabEditMode}
                        <input type="text" value={rowEdits.discounts || ''} on:input={(e) => { rowEdits.discounts = e.currentTarget.value; pricingTabEdits = pricingTabEdits; }} class="number-input-cell" placeholder="$0" />
                      {:else}
                        <span class="value-display">{customData.discounts || '-'}</span>
                      {/if}
                    </td>
                    <td class="field-col">
                      {#if pricingTabEditMode}
                        <input type="text" value={rowEdits.price_adjustments || ''} on:input={(e) => { rowEdits.price_adjustments = e.currentTarget.value; pricingTabEdits = pricingTabEdits; }} class="text-input-cell" placeholder="Notes..." />
                      {:else}
                        <span class="value-display">{customData.price_adjustments || '-'}</span>
                      {/if}
                    </td>
                  </tr>
                {/each}
              </tbody>
            </table>
          </div>
        {:else}
          <div class="table-scroll-wrapper">
            <table class="data-table">
              <thead>
                <tr>
                  <th class="th-checkbox th-sticky-left">
                    <input type="checkbox" checked={selectedRows.size === tableData.length && tableData.length > 0} on:change={toggleAllRows} title="Select all" />
                  </th>
                  <th class="th-id sortable" style="width: {getColumnWidth('id')}" on:click={() => toggleSort('id')}>
                    <span class="th-content">ID {sortColumn === 'id' ? (sortDirection === 'asc' ? 'â²' : 'â¼') : ''}</span>
                    <!-- svelte-ignore a11y_no_noninteractive_tabindex -->
                    <!-- svelte-ignore a11y_no_noninteractive_element_interactions -->
                    <div class="resize-handle" on:mousedown={(e) => startColumnResize(e, 'id')} role="separator" tabindex="0" aria-orientation="vertical"></div>
                  </th>
                  {#each orderedFields as field}
                    <th 
                      class="th-field sortable" 
                      class:th-num={field.type === 'number'}
                      class:th-status={field.type === 'status'}
                      class:th-date={field.type === 'date'}
                      style="width: {getColumnWidth(field.key)}"
                      on:click={() => toggleSort(field.key)}
                    >
                      <span class="th-content">{field.label} {sortColumn === field.key ? (sortDirection === 'asc' ? 'â²' : 'â¼') : ''}</span>
                      <!-- svelte-ignore a11y_no_noninteractive_tabindex -->
                      <!-- svelte-ignore a11y_no_noninteractive_element_interactions -->
                      <div class="resize-handle" on:mousedown={(e) => startColumnResize(e, field.key)} role="separator" tabindex="0" aria-orientation="vertical"></div>
                    </th>
                  {/each}
                  <th class="th-actions th-sticky-right">
                    Actions
                    <button class="btn-fields-mgr" on:click={() => showFieldsManager = true} title="Manage Fields">â</button>
                  </th>
                </tr>
              </thead>
            <tbody>
              {#if isAdding}
                <tr class="adding-row">
                  <td class="checkbox-col td-sticky-left"></td>
                  <td class="id-col">--</td>
                  {#each orderedFields as field}
                    <td class="field-col" class:num-col={field.type === 'number'} class:status-col={field.type === 'status'} class:date-col={field.type === 'date'}>
                      {#if field.type === 'status'}
                        <select bind:value={newRowValues[field.key]} class="status-select">
                          <option value="">Select...</option>
                          {#each statusOptions as opt}
                            <option value={opt.value}>{opt.label}</option>
                          {/each}
                        </select>
                      {:else if field.type === 'date'}
                        <input type="date" bind:value={newRowValues[field.key]} class="date-input" />
                      {:else if field.type === 'number'}
                        <div class="number-input-wrapper">
                          <input type="text" bind:value={newRowValues[field.key]} placeholder={field.label} />
                          {#if field.format === '$'}
                            <div class="number-presets">
                              {#each numberPresets as preset}
                                <button type="button" class="preset-btn" on:click={() => newRowValues[field.key] = preset.value.toString()}>{preset.label}</button>
                              {/each}
                            </div>
                          {/if}
                        </div>
                      {:else}
                        <input type="text" bind:value={newRowValues[field.key]} placeholder={field.label} />
                      {/if}
                    </td>
                  {/each}
                  <td class="actions-col td-sticky-right">
                    <button class="btn-save" on:click={saveAdd} disabled={savingAdd}>
                      {savingAdd ? 'Saving...' : 'Save'}
                    </button>
                    <button class="btn-cancel" on:click={cancelAdd} disabled={savingAdd}>Cancel</button>
                  </td>
                </tr>
              {/if}
              {#each sortedTableData as row}
                <tr class:editing={editingId === row.id} class:row-selected={selectedRows.has(row.id)}>
                  <td class="checkbox-col td-sticky-left">
                    <input type="checkbox" checked={selectedRows.has(row.id)} on:change={() => toggleRowSelection(row.id)} />
                  </td>
                  <td class="id-col">{row.id}</td>
                  {#if editingId === row.id}
                    {#each orderedFields as field}
                      <td class="field-col" class:num-col={field.type === 'number'} class:status-col={field.type === 'status'} class:date-col={field.type === 'date'}>
                        {#if field.type === 'status'}
                          <select bind:value={editValues[field.key]} class="status-select">
                            <option value="">Select...</option>
                            {#each statusOptions as opt}
                              <option value={opt.value}>{opt.label}</option>
                            {/each}
                          </select>
                        {:else if field.type === 'date'}
                          <input type="date" bind:value={editValues[field.key]} class="date-input" />
                        {:else if field.key === 'price'}
                          {@const lotFrontage = parseFloat(editValues.frontage) || parseFloat(row.frontage) || 0}
                          {@const lotDepth = parseFloat(editValues.depth) || parseFloat(row.depth) || 0}
                          {@const lotArea = parseFloat(editValues.area) || parseFloat(row.area) || lotFrontage * lotDepth}
                          {@const editIndicative = lotFrontage > 0 && lotDepth > 0 ? calculateLotPrice({ frontage: lotFrontage, depth: lotDepth, area: lotArea }) : null}
                          {@const pricedCount = pricingProducts.filter(p => p.basePrice > 0).length}
                          <div class="price-input-wrapper">
                            <input type="text" bind:value={editValues[field.key]} placeholder="Enter price" />
                            {#if editIndicative && pricedCount > 0}
                              <div class="indicative-suggestion">
                                <button type="button" class="btn-use-indicative" on:click={() => { editValues[field.key] = editIndicative.totalPrice.toString(); log(`Lot ${row.lotNumber || row.id}: Base ${editIndicative.matchedProduct} = $${editIndicative.basePrice.toLocaleString()} + Balance $${editIndicative.balancePrice.toLocaleString()} = $${editIndicative.totalPrice.toLocaleString()} ($${editIndicative.pricePerSqm}/mÂ²)`, 'info'); }}>
                                  Use ${editIndicative.totalPrice.toLocaleString()}
                                </button>
                                <span class="base-used">Base: {editIndicative.matchedProduct}</span>
                              </div>
                            {:else if pricedCount === 0}
                              <span class="no-pricing-hint">Set up Pricing Matrix first</span>
                            {/if}
                          </div>
                        {:else if field.type === 'number'}
                          <div class="number-input-wrapper">
                            <input type="text" bind:value={editValues[field.key]} />
                          </div>
                        {:else}
                          <input type="text" bind:value={editValues[field.key]} />
                        {/if}
                      </td>
                    {/each}
                    <td class="actions-col td-sticky-right">
                      <button class="btn-save" on:click={() => saveEdit(row)} disabled={savingRow}>
                        {savingRow ? 'Saving...' : 'Save'}
                      </button>
                      <button class="btn-cancel" on:click={cancelEdit} disabled={savingRow}>Cancel</button>
                    </td>
                  {:else}
                    {#each orderedFields as field}
                      <td class="field-col" class:num-col={field.type === 'number'} class:status-col={field.type === 'status'} class:date-col={field.type === 'date'} class:price-col={field.key === 'price'} class:inline-price-edit={field.key === 'price' && inlinePriceEditMode}>
                        {#if field.key === 'price' && inlinePriceEditMode}
                          {@const indicativePrice = calculateLotPrice(row)}
                          {@const originalPrice = parseFloat(row.price) || 0}
                          {@const currentEditPrice = inlinePriceEdits.has(row.id) ? (inlinePriceEdits.get(row.id) ?? 0) : originalPrice}
                          {@const hasChanged = currentEditPrice !== originalPrice && currentEditPrice > 0}
                          <div class="inline-price-edit-cell" class:has-change={hasChanged}>
                            <input 
                              type="text" 
                              class="inline-price-input" 
                              value={(currentEditPrice ?? 0) > 0 ? (currentEditPrice ?? 0).toLocaleString() : ''}
                              placeholder={originalPrice > 0 ? `Current: $${originalPrice.toLocaleString()}` : 'Enter price'}
                              on:input={(e) => updateInlinePrice(row.id, parseFloat(e.currentTarget.value.replace(/,/g, '')) || 0)}
                            />
                            {#if indicativePrice}
                              <button 
                                type="button" 
                                class="btn-use-indicative-inline" 
                                on:click={() => useIndicativePriceInline(row.id)}
                                title="Base: {indicativePrice.matchedProduct}"
                              >
                                Use ${indicativePrice.totalPrice.toLocaleString()}
                              </button>
                            {/if}
                          </div>
                        {:else if field.key === 'price' && pricingProducts.some(p => p.basePrice > 0)}
                          {@const indicativePrice = calculateLotPrice(row)}
                          {#if row.price && row.price > 0}
                            <span class="price-set">${row.price.toLocaleString()}</span>
                          {:else if indicativePrice}
                            <div class="indicative-price-cell">
                              <span class="indicative-value" title="{indicativePrice.matchedProduct}: Base ${indicativePrice.basePrice.toLocaleString()} + Balance ${indicativePrice.balancePrice.toLocaleString()}">
                                ${indicativePrice.totalPrice.toLocaleString()}
                              </span>
                              <button class="btn-accept-price" on:click={() => acceptIndicativePrice(row, indicativePrice.totalPrice, indicativePrice.pricePerSqm)} title="Accept this price">â</button>
                            </div>
                          {:else}
                            <span class="no-price">-</span>
                          {/if}
                        {:else if field.type === 'status'}
                          {@const status = getStatusOption(row[field.key] || row.status || '')}
                          {#if row[field.key] || row.status}
                            <span class="status-pill" style="color: {status.color}; background: {status.bg};">
                              {status.label}
                            </span>
                          {:else}
                            <span class="no-status">-</span>
                          {/if}
                        {:else if field.type === 'date'}
                          {#if row[field.key] || (field.isCustom && getCustomFieldValue(row, field.key))}
                            {new Date(row[field.key] || getCustomFieldValue(row, field.key)).toLocaleDateString('en-AU')}
                          {:else}
                            -
                          {/if}
                        {:else if field.type === 'number'}
                          {formatNumber(field.isCustom ? getCustomFieldValue(row, field.key) : (row[field.key] ?? row[field.key === 'lotNumber' ? 'lotNumber' : field.key]), field.format || '')}
                        {:else}
                          {field.isCustom ? (getCustomFieldValue(row, field.key) || '-') : (row[field.key] || row[field.key === 'lotNumber' ? 'lotNumber' : field.key] || row.name || '-')}
                        {/if}
                      </td>
                    {/each}
                    <td class="actions-col td-sticky-right">
                      {#if userCanEdit}
                        <button class="btn-edit" on:click={() => startEdit(row)}>Edit</button>
                      {/if}
                      {#if userCanDelete}
                        <button class="btn-delete" on:click={() => deleteRow(row)} disabled={deletingRow === row.id}>
                          {deletingRow === row.id ? '...' : 'Del'}
                        </button>
                      {/if}
                      {#if !userCanEdit && !userCanDelete}
                        <span class="view-only-badge">View Only</span>
                      {/if}
                    </td>
                  {/if}
                </tr>
              {/each}
            </tbody>
          </table>
          </div>
        {/if}
      </div>
      {/if}
      </div>
    </div>
  </div>
  
  <ActivityLogPanel
    entries={activityLog}
    {extractionProgress}
    collapsed={logPanelCollapsed}
    onToggleCollapsed={() => logPanelCollapsed = !logPanelCollapsed}
  />
</div>
{/if}

<ExtractionModals
  show={showExtractionModal}
  {extractionResult}
  saving={savingExtraction}
  onSaveStages={saveExtractedStages}
  onSaveLots={saveExtractedLots}
  onClose={() => { showExtractionModal = false; extractionResult = null; }}
/>


<PricingReviewModal
  show={showPricingReview}
  stageName={selectedNode?.name || 'Stage'}
  {tableData}
  {statusOptions}
  {calculateLotPrice}
  onSaveAll={handleSaveAllPrices}
  onCancel={cancelPricingReview}
/>

{#if previewDocument}
  <div class="modal-overlay" on:click={() => previewDocument = null} on:keydown={(e) => e.key === 'Escape' && (previewDocument = null)} role="button" tabindex="0">
    <div class="modal preview-modal" on:click|stopPropagation on:keydown|stopPropagation role="dialog" aria-modal="true" tabindex="-1">
      <div class="modal-header">
        <span>ð {previewDocument.originalName}</span>
        <button class="btn-cancel" on:click={() => previewDocument = null}>â</button>
      </div>
      <div class="modal-body preview-body">
        {#if previewDocument.mimeType?.startsWith('image/')}
          <img src="{previewDocument.filename}" alt={previewDocument.originalName} class="preview-image" />
        {:else if previewDocument.mimeType === 'application/pdf'}
          <iframe src="{previewDocument.filename}" title={previewDocument.originalName} class="preview-pdf"></iframe>
        {:else}
          <div class="preview-unsupported">Preview not available for this file type</div>
        {/if}
      </div>
      <div class="modal-footer">
        <a href="{previewDocument.filename}" download={previewDocument.originalName} class="btn-download">Download</a>
        <button class="btn-cancel" on:click={() => previewDocument = null}>Close</button>
      </div>
    </div>
  </div>
{/if}

{#if showCalibrationModal}
  <div class="modal-overlay" on:click={() => showCalibrationModal = false} on:keydown={(e) => e.key === 'Escape' && (showCalibrationModal = false)} role="button" tabindex="0">
    <div class="modal calibration-modal" on:click|stopPropagation on:keydown|stopPropagation role="dialog" aria-modal="true" tabindex="-1">
      <div class="modal-header">
        <span>ð¯ Calibration Check - Verify {calibrationSamples.length} Sample Lots</span>
        <button class="btn-cancel" on:click={() => showCalibrationModal = false}>â</button>
      </div>
      <div class="modal-body">
        <div class="calibration-instructions">
          <p>The AI extracted the following sample lots. <strong>Please verify and correct</strong> any values that don't match the document.</p>
          <p class="calibration-hint">Your corrections will help calibrate the AI to find similar errors in other lots.</p>
        </div>
        
        <div class="calibration-samples">
          {#each calibrationSamples as sample, i}
            <div class="calibration-card">
              <div class="calibration-card-header">
                <span class="lot-badge">Lot {sample.lotNumber}</span>
                {#if sample.area !== sample.userArea || sample.frontage !== sample.userFrontage || sample.depth !== sample.userDepth || sample.streetName !== sample.userStreetName}
                  <span class="corrected-badge">âï¸ Corrected</span>
                {/if}
              </div>
              <div class="calibration-fields">
                <label class="calibration-field">
                  <span class="field-label">Area</span>
                  <div class="field-row">
                    <span class="ai-value" class:changed={sample.area !== sample.userArea}>{sample.area || '-'}</span>
                    <span class="arrow">â</span>
                    <input type="text" bind:value={sample.userArea} placeholder="Correct value" class="calibration-input" />
                  </div>
                </label>
                <label class="calibration-field">
                  <span class="field-label">Frontage</span>
                  <div class="field-row">
                    <span class="ai-value" class:changed={sample.frontage !== sample.userFrontage}>{sample.frontage || '-'}</span>
                    <span class="arrow">â</span>
                    <input type="text" bind:value={sample.userFrontage} placeholder="Correct value" class="calibration-input" />
                  </div>
                </label>
                <label class="calibration-field">
                  <span class="field-label">Depth</span>
                  <div class="field-row">
                    <span class="ai-value" class:changed={sample.depth !== sample.userDepth}>{sample.depth || '-'}</span>
                    <span class="arrow">â</span>
                    <input type="text" bind:value={sample.userDepth} placeholder="Correct value" class="calibration-input" />
                  </div>
                </label>
                <label class="calibration-field">
                  <span class="field-label">Street</span>
                  <div class="field-row">
                    <span class="ai-value" class:changed={sample.streetName !== sample.userStreetName}>{sample.streetName || '-'}</span>
                    <span class="arrow">â</span>
                    <input type="text" bind:value={sample.userStreetName} placeholder="Correct value" class="calibration-input" />
                  </div>
                </label>
              </div>
            </div>
          {/each}
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn-cancel" on:click={() => showCalibrationModal = false}>Cancel</button>
        <button class="btn-skip" on:click={skipCalibration}>Skip Calibration</button>
        <button class="btn-save" on:click={submitCalibration} disabled={isCalibrating}>
          {isCalibrating ? 'â³ Calibrating...' : 'â Apply Calibration & Analyze'}
        </button>
      </div>
    </div>
  </div>
{/if}

{#if showVerificationModal && verificationResult}
  <div class="modal-overlay" on:click={() => showVerificationModal = false} on:keydown={(e) => e.key === 'Escape' && (showVerificationModal = false)} role="button" tabindex="0">
    <div class="modal verification-modal" on:click|stopPropagation on:keydown|stopPropagation role="dialog" aria-modal="true" tabindex="-1">
      <div class="modal-header">
        <span>ð Verification Results - Page {pdfPageNumber}</span>
        <button class="btn-cancel" on:click={() => showVerificationModal = false}>â</button>
      </div>
      <div class="modal-body">
        {#if verificationResult.summary}
          <div class="verification-summary">{verificationResult.summary}</div>
        {/if}
        
        {#if verificationResult.corrections?.length > 0}
          <h4>ð Suggested Corrections</h4>
          <table class="extraction-table">
            <thead>
              <tr>
                <th>Lot</th>
                <th>Field</th>
                <th>Current</th>
                <th>Suggested</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody>
              {#each verificationResult.corrections as correction}
                <tr>
                  <td>{correction.lotNumber}</td>
                  <td>{correction.field}</td>
                  <td class="current-val">{correction.currentValue || '-'}</td>
                  <td class="new-val">{correction.newValue || correction.correctValue}</td>
                  <td>
                    <button class="btn-apply-one" on:click={() => applyCorrection(correction)}>Apply</button>
                  </td>
                </tr>
              {/each}
            </tbody>
          </table>
        {:else}
          <div class="empty-msg">No corrections found - data appears accurate!</div>
        {/if}
        
        {#if verificationResult.newLots?.length > 0}
          <h4>â New Lots Found</h4>
          <table class="extraction-table">
            <thead>
              <tr>
                <th>Lot #</th>
                <th>Area</th>
                <th>Frontage</th>
                <th>Depth</th>
                <th>Street</th>
              </tr>
            </thead>
            <tbody>
              {#each verificationResult.newLots as lot}
                <tr>
                  <td>{lot.lotNumber}</td>
                  <td>{lot.area || '-'}</td>
                  <td>{lot.frontage || '-'}</td>
                  <td>{lot.depth || '-'}</td>
                  <td>{lot.streetName || '-'}</td>
                </tr>
              {/each}
            </tbody>
          </table>
        {/if}
        
        {#if verificationResult.error}
          <div class="error-msg">{verificationResult.error}</div>
        {/if}
      </div>
      <div class="modal-footer">
        <button class="btn-cancel" on:click={() => showVerificationModal = false}>Close</button>
        {#if verificationResult.corrections?.length > 0}
          <button class="btn-save" on:click={applyAllCorrections}>
            Apply All ({verificationResult.corrections.length}) Corrections
          </button>
        {/if}
      </div>
    </div>
  </div>
{/if}

{#if showPosAnalysisModal && posAnalysisResult}
  <div class="modal-overlay" on:click={() => showPosAnalysisModal = false} on:keydown={(e) => e.key === 'Escape' && (showPosAnalysisModal = false)} role="button" tabindex="0">
    <div class="modal pos-analysis-modal" on:click|stopPropagation on:keydown|stopPropagation role="dialog" aria-modal="true" tabindex="-1">
      <div class="modal-header">
        <span>ð Plan of Subdivision Analysis {posAnalysisResult.psNumber ? `- ${posAnalysisResult.psNumber}` : ''}</span>
        <button class="btn-cancel" on:click={() => showPosAnalysisModal = false}>â</button>
      </div>
      <div class="modal-body">
        <!-- Summary Stats -->
        {#if posAnalysisResult.summary}
          <div class="pos-summary">
            <div class="summary-stat">
              <span class="stat-value">{posAnalysisResult.summary.totalLots}</span>
              <span class="stat-label">Total Lots</span>
            </div>
            <div class="summary-stat match">
              <span class="stat-value">{posAnalysisResult.summary.matches}</span>
              <span class="stat-label">Match</span>
            </div>
            <div class="summary-stat variance">
              <span class="stat-value">{posAnalysisResult.summary.variances}</span>
              <span class="stat-label">Variances</span>
            </div>
            <div class="summary-stat easement">
              <span class="stat-value">{posAnalysisResult.summary.lotsWithEasements}</span>
              <span class="stat-label">With Easements</span>
            </div>
          </div>
        {/if}
        
        <!-- Filter Tabs -->
        <div class="pos-filter-tabs">
          <button class:active={posAnalysisFilter === 'all'} on:click={() => posAnalysisFilter = 'all'}>
            All ({posAnalysisResult.comparisons?.length || 0})
          </button>
          <button class:active={posAnalysisFilter === 'variance'} on:click={() => posAnalysisFilter = 'variance'}>
            â ï¸ Variances ({posAnalysisResult.summary?.variances || 0})
          </button>
          <button class:active={posAnalysisFilter === 'easements'} on:click={() => posAnalysisFilter = 'easements'}>
            ð Easements ({posAnalysisResult.summary?.lotsWithEasements || 0})
          </button>
          <button class:active={posAnalysisFilter === 'match'} on:click={() => posAnalysisFilter = 'match'}>
            â Match ({posAnalysisResult.summary?.matches || 0})
          </button>
        </div>
        
        <!-- Lot Comparisons -->
        <div class="pos-comparisons">
          {#each getFilteredComparisons() as comp}
            <div class="pos-lot-card {comp.status}">
              <div class="lot-card-header" on:click={() => toggleLotExpanded(comp.lotNumber)} on:keydown={(e) => e.key === 'Enter' && toggleLotExpanded(comp.lotNumber)} role="button" tabindex="0">
                <span class="lot-number">Lot {comp.lotNumber}</span>
                <span class="lot-status-badge {comp.status}">
                  {#if comp.status === 'match'}â Match
                  {:else if comp.status === 'variance'}â ï¸ Variance
                  {:else if comp.status === 'new_data'}ð New Data
                  {/if}
                </span>
                {#if comp.newInfo?.easements?.length > 0}
                  <span class="easement-badge">ð {comp.newInfo.easements.length} Easement{comp.newInfo.easements.length > 1 ? 's' : ''}</span>
                {/if}
                <span class="expand-icon">{expandedLots.has(comp.lotNumber) ? 'â¼' : 'â¶'}</span>
              </div>
              
              {#if expandedLots.has(comp.lotNumber) || comp.status === 'variance'}
                <div class="lot-card-body">
                  <!-- Comparison Table -->
                  <table class="comparison-table">
                    <thead>
                      <tr>
                        <th>Field</th>
                        <th>Existing</th>
                        <th>POS Value</th>
                        <th>Diff</th>
                        <th></th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr class:has-variance={comp.variances.some((v: any) => v.field === 'area')}>
                        <td>Area</td>
                        <td>{comp.existing.area || '-'} mÂ²</td>
                        <td>{comp.extracted.area || '-'} mÂ²</td>
                        <td class="diff-cell">
                          {#if comp.variances.find((v: any) => v.field === 'area')}
                            <span class="diff-value">{comp.variances.find((v: any) => v.field === 'area').difference}</span>
                          {:else}
                            -
                          {/if}
                        </td>
                        <td>
                          {#if comp.variances.find((v: any) => v.field === 'area')}
                            <button class="btn-apply-small" on:click={() => applyPosCorrection(posAnalysisResult.corrections.find((c: any) => c.lotId === comp.lotId && c.field === 'area'))}>Apply</button>
                          {/if}
                        </td>
                      </tr>
                      <tr class:has-variance={comp.variances.some((v: any) => v.field === 'frontage')}>
                        <td>Frontage</td>
                        <td>{comp.existing.frontage || '-'}m</td>
                        <td>{comp.extracted.frontage || '-'}m</td>
                        <td class="diff-cell">
                          {#if comp.variances.find((v: any) => v.field === 'frontage')}
                            <span class="diff-value">{comp.variances.find((v: any) => v.field === 'frontage').difference}</span>
                          {:else}
                            -
                          {/if}
                        </td>
                        <td>
                          {#if comp.variances.find((v: any) => v.field === 'frontage')}
                            <button class="btn-apply-small" on:click={() => applyPosCorrection(posAnalysisResult.corrections.find((c: any) => c.lotId === comp.lotId && c.field === 'frontage'))}>Apply</button>
                          {/if}
                        </td>
                      </tr>
                      <tr class:has-variance={comp.variances.some((v: any) => v.field === 'depth')}>
                        <td>Depth</td>
                        <td>{comp.existing.depth || '-'}m</td>
                        <td>{comp.extracted.depth || '-'}m</td>
                        <td class="diff-cell">
                          {#if comp.variances.find((v: any) => v.field === 'depth')}
                            <span class="diff-value">{comp.variances.find((v: any) => v.field === 'depth').difference}</span>
                          {:else}
                            -
                          {/if}
                        </td>
                        <td>
                          {#if comp.variances.find((v: any) => v.field === 'depth')}
                            <button class="btn-apply-small" on:click={() => applyPosCorrection(posAnalysisResult.corrections.find((c: any) => c.lotId === comp.lotId && c.field === 'depth'))}>Apply</button>
                          {/if}
                        </td>
                      </tr>
                    </tbody>
                  </table>
                  
                  <!-- Easements -->
                  {#if comp.newInfo?.easements?.length > 0}
                    <div class="easements-section">
                      <h5>ð Easements</h5>
                      <div class="easements-list">
                        {#each comp.newInfo.easements as easement}
                          <div class="easement-item">
                            <span class="easement-id">{easement.id}</span>
                            <span class="easement-type">{easement.type}</span>
                            {#if easement.width}<span class="easement-width">{easement.width}</span>{/if}
                            {#if easement.purpose}<span class="easement-purpose">{easement.purpose}</span>{/if}
                            {#if easement.beneficiary}<span class="easement-beneficiary">â {easement.beneficiary}</span>{/if}
                          </div>
                        {/each}
                      </div>
                    </div>
                  {/if}
                  
                  <!-- Encumbrances -->
                  {#if comp.newInfo?.encumbrances?.length > 0}
                    <div class="encumbrances-section">
                      <h5>â ï¸ Encumbrances</h5>
                      <div class="encumbrances-list">
                        {#each comp.newInfo.encumbrances as enc}
                          <div class="encumbrance-item">
                            <span class="enc-type">{enc.type}</span>
                            <span class="enc-desc">{enc.description}</span>
                          </div>
                        {/each}
                      </div>
                    </div>
                  {/if}
                  
                  <!-- Restrictions -->
                  {#if comp.newInfo?.restrictions?.length > 0}
                    <div class="restrictions-section">
                      <h5>ð Restrictions</h5>
                      <div class="restrictions-list">
                        {#each comp.newInfo.restrictions as rest}
                          <div class="restriction-item">
                            <span class="rest-type">{rest.type}</span>
                            <span class="rest-desc">{rest.description}</span>
                          </div>
                        {/each}
                      </div>
                    </div>
                  {/if}
                </div>
              {/if}
            </div>
          {/each}
        </div>
        
        <!-- General Easements -->
        {#if posAnalysisResult.generalEasements?.length > 0}
          <div class="general-easements-section">
            <h4>ð General Easements Affecting Multiple Lots</h4>
            <div class="general-easements-list">
              {#each posAnalysisResult.generalEasements as ge}
                <div class="general-easement-item">
                  <span class="ge-id">{ge.id}</span>
                  <span class="ge-type">{ge.type}</span>
                  {#if ge.width}<span class="ge-width">{ge.width}</span>{/if}
                  <span class="ge-lots">Affects: {ge.affectedLots?.join(', ') || 'Unknown'}</span>
                </div>
              {/each}
            </div>
          </div>
        {/if}
      </div>
      <div class="modal-footer">
        <button class="btn-cancel" on:click={() => showPosAnalysisModal = false}>Close</button>
        {#if posAnalysisResult.corrections?.length > 0}
          <button class="btn-save" on:click={applyAllPosCorrections}>
            Apply All ({posAnalysisResult.corrections.length}) Corrections
          </button>
        {/if}
      </div>
    </div>
  </div>
{/if}

{#if showPreExtractionModal}
  <div class="modal-overlay" on:click={cancelPreExtraction} on:keydown={(e) => e.key === 'Escape' && cancelPreExtraction()} role="button" tabindex="0">
    <div class="modal pre-extraction-modal" on:click|stopPropagation on:keydown|stopPropagation role="dialog" aria-modal="true" tabindex="-1">
      <div class="modal-header">
        <span>ð¡ Extraction Context</span>
        <button class="btn-cancel" on:click={cancelPreExtraction}>â</button>
      </div>
      <div class="modal-body">
        <div class="pre-extraction-info">
          <p>You can provide context to help the AI extract data more accurately. This is <strong>optional</strong> but can significantly improve results.</p>
          
          <div class="hints-examples">
            <h4>Helpful information to include:</h4>
            <ul>
              <li><strong>Stage names/numbers</strong> - e.g., "This plan has Stage 40, 41, and 42"</li>
              <li><strong>Lot numbering pattern</strong> - e.g., "Lots start with stage number: 4001 = Stage 40, Lot 1"</li>
              <li><strong>Street names</strong> - e.g., "Streets: Main St, Oak Ave, Park Rd"</li>
              <li><strong>Approximate lot count</strong> - e.g., "About 120 lots total"</li>
            </ul>
          </div>
          
          <textarea 
            class="hints-textarea-large"
            bind:value={extractionHints}
            placeholder="Example:
This Permit Plan has 3 stages: Stage 40, 41, and 42
Lot numbers start with the stage number:
- Stage 40: Lots 4001-4050
- Stage 41: Lots 4101-4140
- Stage 42: Lots 4201-4230
Street names: Maple Drive, Oak Avenue, Park Road"
            rows="6"
          ></textarea>
        </div>
        
        <div class="model-selection">
          <label for="ai-model-select">AI Model:</label>
          <select id="ai-model-select" bind:value={selectedModel}>
            {#each modelOptions as model}
              <option value={model.id}>{model.name}</option>
            {/each}
          </select>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn-cancel" on:click={cancelPreExtraction}>Cancel</button>
        <button class="btn-secondary" on:click={() => { extractionHints = ''; confirmExtraction(); }}>
          Skip Context
        </button>
        <button class="btn-save" on:click={confirmExtraction}>
          ð¤ Start Extraction
        </button>
      </div>
    </div>
  </div>
{/if}

{#if showContinueModal && continuationInfo}
  <div class="modal-overlay" on:click={() => showContinueModal = false} on:keydown={(e) => e.key === 'Escape' && (showContinueModal = false)} role="button" tabindex="0">
    <div class="modal continue-modal" on:click|stopPropagation on:keydown|stopPropagation role="dialog" aria-modal="true" tabindex="-1">
      <div class="modal-header">
        <span>ð More Data Available</span>
        <button class="btn-cancel" on:click={() => showContinueModal = false}>â</button>
      </div>
      <div class="modal-body">
        <div class="continue-info">
          <p>The AI has extracted partial data and detected more content:</p>
          <div class="continue-details">
            <div class="detail-row">
              <span class="label">Remaining Stages:</span>
              <span class="value">{continuationInfo.remainingStages.join(', ') || 'Unknown'}</span>
            </div>
            <div class="detail-row">
              <span class="label">Estimated Lots:</span>
              <span class="value">~{continuationInfo.estimatedLots} lots</span>
            </div>
            <div class="detail-row">
              <span class="label">Est. Token Cost:</span>
              <span class="value">~{Math.ceil(continuationInfo.estimatedLots * 50)} tokens</span>
            </div>
          </div>
          <p class="continue-note">Continue extraction to get the remaining data?</p>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn-cancel" on:click={() => { showContinueModal = false; continuationInfo = null; showExtractionModal = true; }}>
          â Save Current Data
        </button>
        <button class="btn-save" on:click={continueExtraction}>
          â Continue Extraction
        </button>
      </div>
    </div>
  </div>
{/if}

<FieldsManagerModal
  show={showFieldsManager}
  entityType={getCustomFieldEntityType() || 'lot'}
  {customFields}
  {hiddenFields}
  fieldOrder={orderedFields.map(f => f.key)}
  onFieldAdded={handleFieldAdded}
  onFieldRemoved={removeCustomField}
  onVisibilityToggled={toggleFieldVisibility}
  onFieldOrderChanged={handleFieldOrderChanged}
  onClose={() => showFieldsManager = false}
/>

{#if canManageUsers}
  <UserManagementModal
    show={showUserManagement}
    {currentUser}
    onClose={() => showUserManagement = false}
    onLog={log}
  />
{/if}

<NewCompanyModal
  show={showNewCompanyModal}
  onCreate={handleCreateCompany}
  onClose={() => showNewCompanyModal = false}
/>

<style>
  /* ===== THEME SYSTEM ===== */
  :global(:root) {
    /* Default Theme (Tokyo Night) */
    --bg-primary: #1a1b26;
    --bg-secondary: #24283b;
    --bg-tertiary: #292e42;
    --bg-hover: #3b4261;
    --text-primary: #c0caf5;
    --text-secondary: #a9b1d6;
    --text-muted: #565f89;
    --accent-primary: #7aa2f7;
    --accent-secondary: #bb9af7;
    --accent-success: #9ece6a;
    --accent-warning: #e0af68;
    --accent-error: #f7768e;
    --border-color: #3b4261;
    --input-bg: #1a1b26;
    --table-header: #292e42;
    --table-row-alt: #1f2335;
  }
  
  :global([data-theme="tokyo-night"]) {
    --bg-primary: #ffffff;
    --bg-secondary: #f8f9fa;
    --bg-tertiary: #f1f3f4;
    --bg-hover: #e8eaed;
    --text-primary: #202124;
    --text-secondary: #3c4043;
    --text-muted: #5f6368;
    --accent-primary: #1a73e8;
    --accent-secondary: #8430ce;
    --accent-success: #1e8e3e;
    --accent-warning: #f9ab00;
    --accent-error: #d93025;
    --border-color: #dadce0;
    --input-bg: #ffffff;
    --table-header: #f1f3f4;
    --table-row-alt: #f8f9fa;
  }
  
  :global([data-theme="console"]) {
    --bg-primary: #0a0a0a;
    --bg-secondary: #141414;
    --bg-tertiary: #1e1e1e;
    --bg-hover: #2a2a2a;
    --text-primary: #33ff33;
    --text-secondary: #22cc22;
    --text-muted: #117711;
    --accent-primary: #33ff33;
    --accent-secondary: #00ffff;
    --accent-success: #33ff33;
    --accent-warning: #ffff00;
    --accent-error: #ff3333;
    --border-color: #33ff33;
    --input-bg: #0a0a0a;
    --table-header: #1a1a1a;
    --table-row-alt: #0f0f0f;
  }
  
  :global([data-theme="ocean"]) {
    --bg-primary: #1e3a5f;
    --bg-secondary: #264b7a;
    --bg-tertiary: #2d5a94;
    --bg-hover: #3d6aa4;
    --text-primary: #ffffff;
    --text-secondary: #e0e8f0;
    --text-muted: #8fa8c8;
    --accent-primary: #5dade2;
    --accent-secondary: #af7ac5;
    --accent-success: #58d68d;
    --accent-warning: #f4d03f;
    --accent-error: #ec7063;
    --border-color: #5dade2;
    --input-bg: #1a3050;
    --table-header: #2d5a94;
    --table-row-alt: #234a74;
  }
  
  :global([data-theme="high-contrast"]) {
    --bg-primary: #000000;
    --bg-secondary: #0a0a0a;
    --bg-tertiary: #1a1a1a;
    --bg-hover: #2a2a2a;
    --text-primary: #ffffff;
    --text-secondary: #f0f0f0;
    --text-muted: #b0b0b0;
    --accent-primary: #00d4ff;
    --accent-secondary: #ff00ff;
    --accent-success: #00ff00;
    --accent-warning: #ffff00;
    --accent-error: #ff0000;
    --border-color: #ffffff;
    --input-bg: #000000;
    --table-header: #1a1a1a;
    --table-row-alt: #0f0f0f;
  }
  
  /* Apply theme variables */
  :global(body) {
    background: var(--bg-primary);
    color: var(--text-primary);
  }
  
  /* Theme Selector Styles */
  .theme-selector {
    display: flex;
    gap: 6px;
    padding: 8px 12px;
    align-items: center;
  }
  
  .theme-selector-label {
    font-size: 11px;
    color: var(--text-muted);
    margin-right: 4px;
  }
  
  .theme-btn {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: 2px solid transparent;
    cursor: pointer;
    transition: all 0.15s;
    position: relative;
  }
  
  .theme-btn:hover {
    transform: scale(1.1);
  }
  
  .theme-btn.active {
    border-color: var(--accent-primary);
    box-shadow: 0 0 8px var(--accent-primary);
  }
  
  .theme-btn.default {
    background: linear-gradient(135deg, #1a1b26 50%, #7aa2f7 50%);
  }
  
  .theme-btn.tokyo-night {
    background: linear-gradient(135deg, #d5d6db 50%, #34548a 50%);
  }
  
  .theme-btn.console {
    background: linear-gradient(135deg, #0a0a0a 50%, #33ff33 50%);
  }
  
  .theme-btn.ocean {
    background: linear-gradient(135deg, #1e3a5f 50%, #5dade2 50%);
  }
  
  /* Auth Loading */
  .auth-loading {
    height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: var(--bg-primary);
    color: var(--text-secondary);
    font-family: 'JetBrains Mono', monospace;
    gap: 16px;
  }
  
  .loading-spinner {
    width: 32px;
    height: 32px;
    border: 3px solid var(--border-color);
    border-top-color: var(--accent-primary);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  .btn-primary {
    padding: 8px 16px;
    background: #7aa2f7;
    color: #1a1b26;
    border: none;
    border-radius: 4px;
    font-family: inherit;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
  }
  
  .btn-primary:hover {
    background: #89b4fa;
  }
  
  .loading-state, .empty-state {
    color: var(--text-muted);
    text-align: center;
    padding: 24px;
  }
  
  .app {
    height: 100vh;
    display: flex;
    flex-direction: column;
    background: var(--bg-primary);
    color: var(--text-secondary);
    font-family: 'JetBrains Mono', 'Fira Code', 'Courier New', monospace;
    font-size: 13px;
    overflow: hidden;
  }
  
  .header {
    padding: 12px 16px;
    border-bottom: 1px solid #3b4261;
    display: flex;
    gap: 16px;
    align-items: center;
  }
  
  .title {
    color: #7dcfff;
    font-weight: bold;
    font-size: 15px;
  }
  
  .subtitle {
    color: var(--text-muted);
    font-size: 12px;
  }
  
  .main {
    flex: 1;
    display: flex;
    overflow: hidden;
    min-height: 0;
  }
  
  .tree-panel {
    width: 350px;
    border-right: 1px solid #3b4261;
    display: flex;
    flex-direction: column;
    min-height: 0;
  }
  
  .table-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
    overflow: hidden;
  }
  
  .table-panel-scroll {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    min-height: 0;
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE/Edge */
  }
  
  .table-panel-scroll::-webkit-scrollbar {
    display: none; /* Chrome/Safari */
  }
  
  .hierarchy-path {
    padding: 8px 12px;
    background: var(--bg-primary);
    border-bottom: 1px solid #3b4261;
    display: flex;
    align-items: center;
    gap: 6px;
    flex-wrap: wrap;
    font-size: 11px;
  }
  
  .path-label {
    color: var(--text-muted);
  }
  
  .path-sep {
    color: #3b4261;
  }
  
  .path-item {
    font-size: 11px;
  }
  
  .properties-section {
    border-bottom: 1px solid #3b4261;
    flex-shrink: 0;
  }
  
  .properties-grid {
    padding: 8px 12px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    background: var(--input-bg);
    max-height: 250px;
    overflow-y: auto;
  }
  
  .property-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .property-label {
    color: #7aa2f7;
    width: 110px;
    flex-shrink: 0;
    font-size: 11px;
    white-space: nowrap;
  }
  
  .property-value {
    color: #9ece6a;
    flex: 1;
    min-width: 100px;
  }
  
  .property-row .btn-edit {
    margin-left: auto;
  }
  
  .property-input {
    flex: 1;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    color: var(--text-primary);
    padding: 4px 8px;
    font-family: inherit;
    font-size: 12px;
    border-radius: 3px;
  }
  
  .panel-header {
    padding: 8px 12px;
    color: #bb9af7;
    border-bottom: 1px solid #3b4261;
    background: var(--input-bg);
    font-size: 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .panel-header.tree-header {
    flex-shrink: 0;
  }
  
  .tree-toggle-btn {
    display: none;
  }
  
  .add-company-btn {
    padding: 4px 10px;
    background: #9ece6a;
    color: #1a1b26;
    border: none;
    border-radius: 3px;
    font-family: inherit;
    font-size: 11px;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s;
  }
  
  .add-company-btn:hover {
    background: #a9d574;
  }
  
  .empty-tree {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 40px 20px;
    text-align: center;
    color: var(--text-muted);
  }
  
  .empty-tree p {
    margin: 0 0 16px 0;
    font-size: 14px;
  }
  
  .empty-tree .btn-primary {
    padding: 10px 20px;
  }
  
  .panel-header.collapsible {
    cursor: pointer;
    user-select: none;
  }
  
  .panel-header.collapsible:hover {
    background: var(--table-row-alt);
  }
  
  .add-btn {
    background: var(--bg-primary);
    border: 1px solid #9ece6a;
    color: #9ece6a;
    padding: 4px 12px;
    font-family: inherit;
    font-size: 11px;
    cursor: pointer;
    border-radius: 3px;
  }
  
  .add-btn:hover:not(:disabled) {
    background: #9ece6a;
    color: #1a1b26;
  }
  
  .add-btn:disabled {
    opacity: 0.5;
    cursor: default;
  }
  
  .tree-content {
    flex: 1;
    overflow-y: auto;
    padding: 8px 0;
  }
  
  .tree-row {
    display: flex;
    align-items: center;
    padding: 2px 8px;
    white-space: nowrap;
  }
  
  .tree-row.selected {
    background: #283457;
  }
  
  .tree-prefix {
    color: #3b4261;
  }
  
  .tree-expand {
    background: none;
    border: none;
    color: var(--text-muted);
    width: 16px;
    padding: 0;
    cursor: pointer;
    font-family: inherit;
    font-size: 11px;
  }
  
  .tree-expand:disabled {
    cursor: default;
  }
  
  .tree-label {
    background: none;
    border: none;
    cursor: pointer;
    font-family: inherit;
    font-size: inherit;
    padding: 2px 4px;
    text-align: left;
  }
  
  .tree-label:hover {
    text-decoration: underline;
  }
  
  .table-content {
    padding: 8px;
    display: flex;
    flex-direction: column;
    flex: 1;
    min-height: 0;
    overflow: hidden;
  }
  
  .table-scroll-wrapper {
    flex: 1;
    overflow: auto;
    position: relative;
    min-height: 0;
    max-height: calc(100vh - 300px);
  }
  
  .loading-msg, .empty-msg {
    color: var(--text-muted);
    padding: 20px;
    text-align: center;
  }
  
  table.data-table {
    width: max-content;
    min-width: 100%;
    border-collapse: collapse;
    table-layout: fixed;
  }
  
  th {
    text-align: left;
    padding: 8px 12px;
    color: #7aa2f7;
    border-bottom: 1px solid #3b4261;
    font-weight: normal;
    font-size: 11px;
    text-transform: uppercase;
    white-space: nowrap;
    position: sticky;
    top: 0;
    background: var(--bg-primary);
    z-index: 2;
  }
  
  thead tr {
    background: var(--bg-primary);
  }
  
  thead {
    position: sticky;
    top: 0;
    z-index: 3;
    background: var(--bg-primary);
  }
  
  th.sortable {
    cursor: pointer;
    user-select: none;
  }
  
  th.sortable:hover {
    color: #bb9af7;
    background: var(--table-row-alt);
  }
  
  .th-content {
    display: inline-block;
    padding-right: 8px;
  }
  
  .resize-handle {
    position: absolute;
    right: 0;
    top: 0;
    bottom: 0;
    width: 5px;
    cursor: col-resize;
    background: transparent;
    z-index: 1;
  }
  
  .resize-handle:hover {
    background: #7aa2f7;
  }
  
  /* Sticky columns */
  .th-sticky-left, .td-sticky-left {
    position: sticky;
    left: 0;
    z-index: 2;
    background: var(--bg-primary);
  }
  
  .th-sticky-right, .td-sticky-right {
    position: sticky;
    right: 0;
    z-index: 2;
    background: var(--bg-primary);
    box-shadow: -2px 0 4px rgba(0,0,0,0.3);
  }
  
  td {
    padding: 6px 12px;
    border-bottom: 1px solid #24283b;
    white-space: nowrap;
    background: var(--bg-primary);
  }
  
  tr:hover td {
    background: var(--table-row-alt);
  }
  
  .th-id { width: 50px; }
  .th-name { width: 100px; }
  .th-num { width: 70px; }
  .th-street { width: 120px; }
  .th-detail { flex: 1; }
  .th-actions { width: 100px; }
  
  .id-col { color: var(--text-muted); width: 50px; }
  .name-col { color: #9ece6a; }
  .num-col { color: #7dcfff; text-align: right; width: 70px; }
  .street-col { color: #bb9af7; width: 120px; }
  .detail-col { color: var(--text-secondary); }
  .actions-col { width: 100px; }
  
  tr.editing td, tr.adding-row td {
    background: var(--table-row-alt);
  }
  
  input[type="text"] {
    background: var(--input-bg);
    border: 1px solid var(--border-color);
    color: var(--text-primary);
    padding: 4px 8px;
    font-family: inherit;
    font-size: 12px;
    width: 100%;
    box-sizing: border-box;
    border-radius: 3px;
  }
  
  input[type="text"]:focus {
    outline: none;
    border-color: #7aa2f7;
  }
  
  .btn-edit, .btn-delete, .btn-save, .btn-cancel {
    background: none;
    border: 1px solid;
    padding: 2px 8px;
    font-family: inherit;
    font-size: 10px;
    cursor: pointer;
    border-radius: 2px;
    margin-right: 4px;
  }
  
  .btn-edit {
    color: #7aa2f7;
    border-color: #7aa2f7;
  }
  
  .btn-edit:hover {
    background: #7aa2f7;
    color: #1a1b26;
  }
  
  .btn-delete {
    color: #f7768e;
    border-color: #f7768e;
  }
  
  .btn-delete:hover {
    background: #f7768e;
    color: #1a1b26;
  }
  
  .view-only-badge {
    font-size: 10px;
    color: var(--text-muted);
    font-style: italic;
  }
  
  .btn-save {
    color: #9ece6a;
    border-color: #9ece6a;
  }
  
  .btn-save:hover {
    background: #9ece6a;
    color: #1a1b26;
  }
  
  .btn-cancel {
    color: #e0af68;
    border-color: #e0af68;
  }
  
  .btn-cancel:hover {
    background: #e0af68;
    color: #1a1b26;
  }
  
  /* Inline document viewer */
  .inline-viewer-section {
    border: 1px solid var(--border-color);
    border-radius: 4px;
    margin-bottom: 8px;
    overflow: hidden;
  }
  
  .inline-viewer-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 12px;
    background: var(--input-bg);
    border-bottom: 1px solid #3b4261;
    color: #7dcfff;
    font-size: 11px;
  }
  
  .inline-viewer-controls {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  
  .zoom-btn {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    color: var(--text-primary);
    padding: 2px 8px;
    font-size: 10px;
    cursor: pointer;
    border-radius: 2px;
  }
  
  .zoom-btn:hover {
    background: #3b4261;
  }
  
  .zoom-level {
    color: #9ece6a;
    font-size: 10px;
    min-width: 40px;
    text-align: center;
  }
  
  .height-slider {
    width: 60px;
    height: 4px;
    cursor: pointer;
  }
  
  .btn-close-inline {
    background: none;
    border: 1px solid #f7768e;
    color: #f7768e;
    padding: 2px 6px;
    font-size: 10px;
    cursor: pointer;
    border-radius: 2px;
  }
  
  .btn-close-inline:hover {
    background: #f7768e;
    color: #1a1b26;
  }
  
  .inline-viewer-container {
    overflow: auto;
    background: var(--input-bg);
  }
  
  .inline-viewer-pdf {
    width: 100%;
    height: 100%;
    border: none;
  }
  
  .inline-viewer-scroll {
    min-width: 100%;
    min-height: 100%;
  }
  
  .inline-viewer-image {
    display: block;
    max-width: none;
  }
  
  /* Bulk edit bar */
  .bulk-edit-bar {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background: rgba(122, 162, 247, 0.1);
    border: 1px solid #7aa2f7;
    border-radius: 4px;
    margin-bottom: 8px;
  }
  
  .bulk-selected {
    color: #7aa2f7;
    font-weight: bold;
    font-size: 11px;
  }
  
  .bulk-field-select, .bulk-value-input {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    color: var(--text-primary);
    padding: 4px 8px;
    font-family: inherit;
    font-size: 11px;
    border-radius: 3px;
  }
  
  .bulk-value-input {
    flex: 1;
    max-width: 200px;
  }
  
  .btn-bulk-apply {
    background: #7aa2f7;
    border: none;
    color: #1a1b26;
    padding: 4px 12px;
    font-family: inherit;
    font-size: 11px;
    cursor: pointer;
    border-radius: 3px;
    font-weight: bold;
  }
  
  .btn-bulk-apply:hover:not(:disabled) {
    background: #9db5f8;
  }
  
  .btn-bulk-apply:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .btn-bulk-clear {
    background: none;
    border: 1px solid #565f89;
    color: var(--text-muted);
    padding: 4px 8px;
    font-family: inherit;
    font-size: 11px;
    cursor: pointer;
    border-radius: 3px;
  }
  
  .btn-bulk-clear:hover {
    border-color: var(--text-primary);
    color: var(--text-primary);
  }
  
  /* Checkbox column */
  .th-checkbox, .checkbox-col {
    width: 30px;
    text-align: center;
  }
  
  /* Terminal-themed checkboxes */
  .th-checkbox input[type="checkbox"],
  .checkbox-col input[type="checkbox"] {
    appearance: none;
    -webkit-appearance: none;
    width: 18px;
    height: 18px;
    background: transparent;
    border: none;
    cursor: pointer;
    position: relative;
    vertical-align: middle;
  }
  
  .th-checkbox input[type="checkbox"]::before,
  .checkbox-col input[type="checkbox"]::before {
    content: '[ ]';
    font-family: monospace;
    font-size: 12px;
    color: var(--text-muted);
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }
  
  .th-checkbox input[type="checkbox"]:checked::before,
  .checkbox-col input[type="checkbox"]:checked::before {
    content: '[Ã]';
    color: #7aa2f7;
  }
  
  .th-checkbox input[type="checkbox"]:hover::before,
  .checkbox-col input[type="checkbox"]:hover::before {
    color: #7dcfff;
  }
  
  .row-selected {
    background: rgba(122, 162, 247, 0.15) !important;
  }
  
  .row-selected:hover {
    background: rgba(122, 162, 247, 0.25) !important;
  }
  
  .stage-section {
    margin-bottom: 16px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    overflow: hidden;
  }
  
  .stage-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background: var(--input-bg);
    border-bottom: 1px solid #3b4261;
  }
  
  .stage-name {
    color: #9ece6a;
    font-weight: bold;
  }
  
  .stage-lot-count {
    color: var(--text-muted);
    font-size: 11px;
  }
  
  .stage-lots {
    margin: 0;
  }
  
  .stage-lots th, .stage-lots td {
    padding: 4px 8px;
    font-size: 11px;
  }
  
  .more-lots {
    color: var(--text-muted);
    font-style: italic;
    text-align: center;
  }
  
  /* Extraction Hints */
  .extraction-hints-section {
    margin: 8px 0;
    padding: 0;
  }
  
  .hints-toggle {
    background: var(--bg-secondary);
    border: 1px dashed #565f89;
    color: var(--text-secondary);
    padding: 6px 12px;
    font-size: 11px;
    cursor: pointer;
    border-radius: 4px;
    width: 100%;
    text-align: left;
  }
  
  .hints-toggle:hover {
    border-color: #7aa2f7;
    color: var(--text-primary);
  }
  
  .hints-input-wrapper {
    margin-top: 8px;
    background: var(--table-row-alt);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 8px;
  }
  
  .hints-textarea {
    width: 100%;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    color: var(--text-primary);
    padding: 8px;
    font-family: inherit;
    font-size: 11px;
    border-radius: 4px;
    resize: vertical;
    min-height: 60px;
  }
  
  .hints-textarea::placeholder {
    color: var(--text-muted);
  }
  
  .hints-textarea:focus {
    outline: none;
    border-color: #7aa2f7;
  }
  
  .hints-help {
    margin-top: 6px;
  }
  
  .hint-example {
    color: var(--text-muted);
    font-size: 10px;
    font-style: italic;
  }
  
  .modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
  }
  
  .modal {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    width: 90%;
    max-width: 800px;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
  }
  
  .modal-header {
    padding: 12px 16px;
    border-bottom: 1px solid #3b4261;
    display: flex;
    justify-content: space-between;
    align-items: center;
    color: #7dcfff;
    font-weight: bold;
  }
  
  .modal-body {
    padding: 16px;
    overflow-y: auto;
    flex: 1;
  }
  
  .modal-footer {
    padding: 12px 16px;
    border-top: 1px solid #3b4261;
    display: flex;
    justify-content: flex-end;
    gap: 8px;
  }
  
  .extraction-summary {
    padding: 8px 12px;
    background: var(--input-bg);
    border-radius: 4px;
    margin-bottom: 12px;
    color: var(--text-secondary);
    font-size: 12px;
  }
  
  .extraction-table {
    width: 100%;
    border-collapse: collapse;
  }
  
  .extraction-table th,
  .extraction-table td {
    padding: 8px;
    text-align: left;
    border-bottom: 1px solid #3b4261;
    font-size: 12px;
  }
  
  .extraction-table th {
    color: #7aa2f7;
    background: var(--input-bg);
  }
  
  .extraction-table td {
    color: #9ece6a;
  }
  
  .extraction-stats {
    display: flex;
    gap: 16px;
    margin-bottom: 12px;
    padding: 8px 12px;
    background: var(--input-bg);
    border-radius: 4px;
  }
  
  .stat-update { color: #e0af68; }
  .stat-create { color: #9ece6a; }
  
  .action-select {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    color: var(--text-primary);
    padding: 4px 8px;
    font-family: inherit;
    font-size: 11px;
    border-radius: 3px;
    cursor: pointer;
  }
  
  .action-col { width: 100px; }
  
  .row-update { background: rgba(224, 175, 104, 0.1); }
  .row-create { background: rgba(158, 206, 106, 0.1); }
  .row-skip { opacity: 0.5; }
  
  .compare-cell {
    display: flex;
    align-items: center;
    gap: 4px;
  }
  
  .old-val {
    color: var(--text-muted);
    text-decoration: line-through;
    font-size: 10px;
  }
  
  .arrow {
    color: #7aa2f7;
    font-size: 10px;
  }
  
  .new-val {
    color: #9ece6a;
  }
  
  .status-changed {
    color: #e0af68;
    font-size: 10px;
    padding: 2px 6px;
    background: rgba(224, 175, 104, 0.2);
    border-radius: 3px;
  }
  
  .status-same {
    color: var(--text-muted);
    font-size: 10px;
  }
  
  .status-new {
    color: #9ece6a;
    font-size: 10px;
    padding: 2px 6px;
    background: rgba(158, 206, 106, 0.2);
    border-radius: 3px;
  }
  
  /* PDF Page Controls */
  .page-controls {
    display: flex;
    align-items: center;
    gap: 4px;
    margin-right: 8px;
  }
  
  .page-btn {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    color: #7aa2f7;
    padding: 2px 6px;
    cursor: pointer;
    border-radius: 2px;
    font-size: 10px;
  }
  
  .page-btn:hover {
    background: #3b4261;
  }
  
  .page-indicator {
    color: var(--text-secondary);
    font-size: 11px;
    min-width: 50px;
    text-align: center;
  }
  
  .btn-analyze-page {
    background: #2d4f2d;
    border: 1px solid #9ece6a;
    color: #9ece6a;
    padding: 3px 10px;
    font-family: inherit;
    font-size: 11px;
    cursor: pointer;
    border-radius: 3px;
    margin-right: 8px;
  }
  
  .btn-analyze-page:hover:not(:disabled) {
    background: #9ece6a;
    color: #1a1b26;
  }
  
  .btn-analyze-page:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .model-selector {
    background: var(--bg-primary);
    border: 1px solid #414868;
    color: var(--text-primary);
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 11px;
    cursor: pointer;
    margin-right: 4px;
  }
  
  .model-selector:hover {
    border-color: #7aa2f7;
  }
  
  .model-selector:focus {
    outline: none;
    border-color: #7aa2f7;
    box-shadow: 0 0 0 2px rgba(122, 162, 247, 0.2);
  }
  
  .model-selector-small {
    background: var(--bg-primary);
    border: 1px solid #414868;
    color: var(--text-primary);
    padding: 2px 4px;
    border-radius: 3px;
    font-size: 10px;
    cursor: pointer;
  }
  
  .model-selector-small:hover {
    border-color: #7aa2f7;
  }
  
  .btn-crossref {
    background: #2d3a4f;
    border: 1px solid #7dcfff;
    color: #7dcfff;
    padding: 2px 6px;
    font-size: 10px;
    cursor: pointer;
    border-radius: 3px;
  }
  
  .btn-crossref:hover:not(:disabled) {
    background: #7dcfff;
    color: #1a1b26;
  }
  
  .btn-crossref:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .btn-capture {
    background: #2d3a4f;
    border: 1px solid #7aa2f7;
    color: #7aa2f7;
    padding: 3px 10px;
    font-family: inherit;
    font-size: 11px;
    cursor: pointer;
    border-radius: 3px;
  }
  
  .btn-capture:hover:not(:disabled) {
    background: #7aa2f7;
    color: #1a1b26;
  }
  
  .btn-capture:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .capture-indicator {
    color: #9ece6a;
    font-size: 12px;
    margin-left: -4px;
  }
  
  .btn-clear-capture {
    background: none;
    border: 1px solid #f7768e;
    color: #f7768e;
    padding: 1px 5px;
    font-size: 10px;
    cursor: pointer;
    border-radius: 2px;
    margin-left: -4px;
  }
  
  .btn-clear-capture:hover {
    background: #f7768e;
    color: #1a1b26;
  }
  
  /* Pre-Extraction Modal */
  .pre-extraction-modal {
    max-width: 600px;
  }
  
  .pre-extraction-info p {
    margin: 0 0 16px;
    color: var(--text-secondary);
    line-height: 1.5;
  }
  
  .pre-extraction-info p strong {
    color: #e0af68;
  }
  
  .hints-examples {
    background: var(--table-row-alt);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 12px 16px;
    margin-bottom: 16px;
  }
  
  .hints-examples h4 {
    margin: 0 0 10px;
    color: #7aa2f7;
    font-size: 13px;
  }
  
  .hints-examples ul {
    margin: 0;
    padding-left: 20px;
    color: var(--text-secondary);
    font-size: 12px;
  }
  
  .hints-examples li {
    margin-bottom: 6px;
  }
  
  .hints-examples li strong {
    color: #9ece6a;
  }
  
  .hints-textarea-large {
    width: 100%;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    color: var(--text-primary);
    padding: 12px;
    font-family: inherit;
    font-size: 12px;
    border-radius: 6px;
    resize: vertical;
    min-height: 120px;
  }
  
  .hints-textarea-large::placeholder {
    color: var(--text-muted);
  }
  
  .hints-textarea-large:focus {
    outline: none;
    border-color: #7aa2f7;
    box-shadow: 0 0 0 2px rgba(122, 162, 247, 0.2);
  }
  
  .model-selection {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 16px;
    padding-top: 16px;
    border-top: 1px solid #3b4261;
  }
  
  .model-selection label {
    color: var(--text-secondary);
    font-size: 12px;
  }
  
  .model-selection select {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    color: var(--text-primary);
    padding: 6px 10px;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
  }
  
  .model-selection select:hover {
    border-color: #7aa2f7;
  }
  
  .btn-secondary {
    background: var(--bg-secondary);
    border: 1px solid #565f89;
    color: var(--text-secondary);
    padding: 8px 16px;
    font-family: inherit;
    font-size: 12px;
    cursor: pointer;
    border-radius: 4px;
  }
  
  .btn-secondary:hover {
    background: #3b4261;
    color: var(--text-primary);
  }
  
  /* Continue Extraction Modal */
  .continue-modal {
    max-width: 450px;
  }
  
  .continue-info p {
    margin: 0 0 12px;
    color: var(--text-secondary);
  }
  
  .continue-details {
    background: var(--bg-secondary);
    padding: 12px;
    border-radius: 4px;
    margin: 12px 0;
  }
  
  .continue-details .detail-row {
    display: flex;
    justify-content: space-between;
    padding: 6px 0;
    border-bottom: 1px solid #3b4261;
  }
  
  .continue-details .detail-row:last-child {
    border-bottom: none;
  }
  
  .continue-details .label {
    color: #7dcfff;
  }
  
  .continue-details .value {
    color: #9ece6a;
    font-weight: bold;
  }
  
  .continue-note {
    color: #e0af68;
    font-style: italic;
  }
  
  /* POS Analysis Button */
  .btn-pos-analyze {
    background: #2d4f3d;
    border: 1px solid #73daca;
    color: #73daca;
    padding: 2px 6px;
    font-size: 10px;
    cursor: pointer;
    border-radius: 3px;
  }
  
  .btn-pos-analyze:hover:not(:disabled) {
    background: #73daca;
    color: #1a1b26;
  }
  
  .btn-pos-analyze:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  /* POS Analysis Modal */
  .pos-analysis-modal {
    max-width: 900px;
    width: 90%;
    max-height: 85vh;
  }
  
  .pos-analysis-modal .modal-body {
    max-height: 70vh;
    overflow-y: auto;
  }
  
  .pos-summary {
    display: flex;
    gap: 16px;
    padding: 16px;
    background: var(--bg-secondary);
    border-radius: 8px;
    margin-bottom: 16px;
  }
  
  .summary-stat {
    flex: 1;
    text-align: center;
    padding: 12px;
    background: var(--bg-primary);
    border-radius: 6px;
    border: 1px solid var(--border-color);
  }
  
  .summary-stat.match {
    border-color: #9ece6a;
  }
  
  .summary-stat.variance {
    border-color: #e0af68;
  }
  
  .summary-stat.easement {
    border-color: #7dcfff;
  }
  
  .stat-value {
    display: block;
    font-size: 24px;
    font-weight: bold;
    color: var(--text-primary);
  }
  
  .summary-stat.match .stat-value { color: #9ece6a; }
  .summary-stat.variance .stat-value { color: #e0af68; }
  .summary-stat.easement .stat-value { color: #7dcfff; }
  
  .stat-label {
    display: block;
    font-size: 11px;
    color: var(--text-muted);
    text-transform: uppercase;
    margin-top: 4px;
  }
  
  .pos-filter-tabs {
    display: flex;
    gap: 8px;
    margin-bottom: 16px;
    border-bottom: 1px solid #3b4261;
    padding-bottom: 8px;
  }
  
  .pos-filter-tabs button {
    background: none;
    border: 1px solid transparent;
    color: var(--text-muted);
    padding: 6px 12px;
    font-size: 12px;
    cursor: pointer;
    border-radius: 4px 4px 0 0;
  }
  
  .pos-filter-tabs button:hover {
    color: var(--text-secondary);
  }
  
  .pos-filter-tabs button.active {
    color: #7aa2f7;
    border-color: #3b4261;
    border-bottom-color: #1a1b26;
    background: var(--bg-primary);
  }
  
  .pos-comparisons {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  
  .pos-lot-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    overflow: hidden;
  }
  
  .pos-lot-card.match { border-left: 3px solid #9ece6a; }
  .pos-lot-card.variance { border-left: 3px solid #e0af68; }
  .pos-lot-card.new_data { border-left: 3px solid #7dcfff; }
  
  .lot-card-header {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 16px;
    cursor: pointer;
    background: var(--table-row-alt);
  }
  
  .lot-card-header:hover {
    background: #292e42;
  }
  
  .lot-number {
    font-weight: bold;
    color: var(--text-primary);
    font-size: 14px;
  }
  
  .lot-status-badge {
    font-size: 11px;
    padding: 2px 8px;
    border-radius: 10px;
    background: #3b4261;
  }
  
  .lot-status-badge.match { background: rgba(158, 206, 106, 0.2); color: #9ece6a; }
  .lot-status-badge.variance { background: rgba(224, 175, 104, 0.2); color: #e0af68; }
  .lot-status-badge.new_data { background: rgba(125, 207, 255, 0.2); color: #7dcfff; }
  
  .easement-badge {
    font-size: 11px;
    padding: 2px 8px;
    border-radius: 10px;
    background: rgba(125, 207, 255, 0.15);
    color: #7dcfff;
    margin-left: auto;
  }
  
  .expand-icon {
    color: var(--text-muted);
    font-size: 10px;
  }
  
  .lot-card-body {
    padding: 16px;
    border-top: 1px solid #3b4261;
  }
  
  .comparison-table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 16px;
  }
  
  .comparison-table th {
    text-align: left;
    padding: 8px;
    color: var(--text-muted);
    font-size: 11px;
    text-transform: uppercase;
    border-bottom: 1px solid #3b4261;
  }
  
  .comparison-table td {
    padding: 8px;
    color: var(--text-secondary);
    font-size: 13px;
    border-bottom: 1px solid #24283b;
  }
  
  .comparison-table tr.has-variance td {
    background: rgba(224, 175, 104, 0.1);
  }
  
  .diff-cell .diff-value {
    color: #e0af68;
    font-weight: bold;
  }
  
  .btn-apply-small {
    background: #2d4f2d;
    border: 1px solid #9ece6a;
    color: #9ece6a;
    padding: 2px 8px;
    font-size: 10px;
    cursor: pointer;
    border-radius: 3px;
  }
  
  .btn-apply-small:hover {
    background: #9ece6a;
    color: #1a1b26;
  }
  
  .easements-section, .encumbrances-section, .restrictions-section {
    margin-top: 16px;
    padding: 12px;
    background: var(--bg-primary);
    border-radius: 6px;
  }
  
  .easements-section h5, .encumbrances-section h5, .restrictions-section h5 {
    margin: 0 0 10px;
    color: #7dcfff;
    font-size: 12px;
  }
  
  .easements-list, .encumbrances-list, .restrictions-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  
  .easement-item, .encumbrance-item, .restriction-item {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    padding: 8px;
    background: var(--bg-secondary);
    border-radius: 4px;
    font-size: 12px;
  }
  
  .easement-id {
    background: #7dcfff;
    color: #1a1b26;
    padding: 1px 6px;
    border-radius: 3px;
    font-weight: bold;
  }
  
  .easement-type {
    color: #bb9af7;
  }
  
  .easement-width {
    color: #9ece6a;
  }
  
  .easement-purpose {
    color: var(--text-secondary);
  }
  
  .easement-beneficiary {
    color: #e0af68;
  }
  
  .enc-type, .rest-type {
    color: #f7768e;
    font-weight: bold;
  }
  
  .enc-desc, .rest-desc {
    color: var(--text-secondary);
    flex: 1;
  }
  
  .general-easements-section {
    margin-top: 20px;
    padding: 16px;
    background: var(--table-row-alt);
    border-radius: 8px;
    border: 1px solid var(--border-color);
  }
  
  .general-easements-section h4 {
    margin: 0 0 12px;
    color: #7dcfff;
    font-size: 14px;
  }
  
  .general-easements-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  
  .general-easement-item {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    padding: 10px;
    background: var(--bg-secondary);
    border-radius: 4px;
    align-items: center;
  }
  
  .ge-id {
    background: #7dcfff;
    color: #1a1b26;
    padding: 2px 8px;
    border-radius: 3px;
    font-weight: bold;
    font-size: 12px;
  }
  
  .ge-type {
    color: #bb9af7;
    font-size: 12px;
  }
  
  .ge-width {
    color: #9ece6a;
    font-size: 12px;
  }
  
  .ge-lots {
    color: var(--text-secondary);
    font-size: 11px;
    margin-left: auto;
  }
  
  /* Fields Manager Modal */
  .fields-modal {
    max-width: 500px;
  }
  
  .fields-section {
    margin-bottom: 20px;
  }
  
  .fields-section h4 {
    color: #bb9af7;
    margin: 0 0 10px;
    font-size: 12px;
  }
  
  .add-field-row {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  
  .add-field-row input {
    flex: 1;
    padding: 6px 8px;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    color: var(--text-secondary);
    font-size: 12px;
  }
  
  .add-field-row select {
    padding: 6px 8px;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    color: var(--text-secondary);
    font-size: 12px;
  }
  
  .field-note {
    font-size: 10px;
    color: var(--text-muted);
    margin-top: 6px;
    font-style: italic;
  }
  
  .empty-fields {
    color: var(--text-muted);
    font-style: italic;
    font-size: 11px;
  }
  
  .fields-list {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  
  .field-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 10px;
    background: var(--bg-secondary);
    border-radius: 4px;
  }
  
  .field-item .field-label {
    flex: 1;
    color: var(--text-secondary);
  }
  
  .field-item .field-type {
    color: var(--text-muted);
    font-size: 10px;
  }
  
  .field-actions {
    display: flex;
    gap: 4px;
  }
  
  .btn-toggle {
    background: none;
    border: none;
    cursor: pointer;
    font-size: 14px;
    padding: 2px 6px;
  }
  
  .btn-toggle.hidden {
    opacity: 0.5;
  }
  
  .btn-fields-mgr {
    background: none;
    border: none;
    color: #7dcfff;
    cursor: pointer;
    font-size: 12px;
    margin-left: 6px;
    padding: 0 4px;
  }
  
  .btn-fields-mgr:hover {
    color: #bb9af7;
  }
  
  .th-custom {
    min-width: 80px;
    max-width: 120px;
    color: #bb9af7;
  }
  
  .custom-col {
    min-width: 80px;
    max-width: 120px;
  }
  
  /* Status Pills */
  .status-pill {
    display: inline-block;
    padding: 3px 10px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 500;
    white-space: nowrap;
  }
  
  .status-select {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    color: var(--text-primary);
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 11px;
    width: 100%;
    cursor: pointer;
  }
  
  .status-select:focus {
    outline: none;
    border-color: #7aa2f7;
  }
  
  .no-status {
    color: var(--text-muted);
  }
  
  .th-status {
    min-width: 100px;
  }
  
  .status-col {
    min-width: 100px;
  }
  
  /* Date Picker */
  .date-input {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    color: var(--text-primary);
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 11px;
    font-family: inherit;
    width: 100%;
  }
  
  .date-input:focus {
    outline: none;
    border-color: #7aa2f7;
  }
  
  .date-input::-webkit-calendar-picker-indicator {
    filter: invert(0.8);
    cursor: pointer;
  }
  
  .th-date {
    min-width: 100px;
  }
  
  .date-col {
    min-width: 100px;
  }
  
  /* Number Input with Presets */
  .number-input-wrapper {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
  
  .number-presets {
    display: flex;
    flex-wrap: wrap;
    gap: 2px;
  }
  
  .preset-btn {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    color: #7dcfff;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 9px;
    cursor: pointer;
    font-family: inherit;
  }
  
  .preset-btn:hover {
    background: #7dcfff;
    color: #1a1b26;
  }
  
  .th-num {
    text-align: right;
    min-width: 80px;
  }
  
  .num-col {
    text-align: right;
  }
  
  /* Field Manager Enhancements */
  .field-hint {
    font-size: 10px;
    color: var(--text-muted);
    font-weight: normal;
    font-style: italic;
  }
  
  .drag-handle {
    cursor: grab;
    color: var(--text-muted);
    font-size: 12px;
    user-select: none;
  }
  
  .drag-handle:active {
    cursor: grabbing;
  }
  
  .field-item {
    cursor: default;
    transition: background 0.15s, opacity 0.15s;
  }
  
  .field-item.field-hidden {
    opacity: 0.5;
    background: var(--bg-primary);
  }
  
  .field-item.field-dragging {
    opacity: 0.5;
    background: #3b4261;
  }
  
  .default-badge {
    background: #3b4261;
    color: #7aa2f7;
    padding: 1px 5px;
    border-radius: 3px;
    font-size: 9px;
    margin-left: 4px;
  }
  
  .format-select {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    color: var(--text-secondary);
    padding: 6px 8px;
    border-radius: 4px;
    font-size: 12px;
  }
  
  /* Dynamic Field Columns */
  .th-field {
    min-width: 80px;
    cursor: pointer;
    user-select: none;
  }
  
  .th-field:hover {
    color: #bb9af7;
    background: var(--table-row-alt);
  }
  
  .field-col {
    min-width: 80px;
  }
  
  .field-col input {
    width: 100%;
    padding: 3px 6px;
    background: var(--input-bg);
    border: 1px solid var(--border-color);
    color: var(--text-primary);
    font-family: inherit;
    font-size: 12px;
    border-radius: 3px;
  }
  
  .field-col input:focus {
    outline: none;
    border-color: #7aa2f7;
  }
  
  /* Original continue-note styling below */
  .continue-note-original {
    color: #e0af68;
    font-style: italic;
  }
  
  /* Verification Modal */
  .verification-modal {
    max-width: 700px;
  }
  
  .verification-summary {
    background: var(--bg-secondary);
    padding: 10px 12px;
    border-radius: 4px;
    margin-bottom: 16px;
    color: #7dcfff;
    font-size: 12px;
  }
  
  .verification-modal h4 {
    color: #bb9af7;
    margin: 16px 0 8px;
    font-size: 12px;
  }
  
  .current-val {
    color: #f7768e;
    text-decoration: line-through;
  }
  
  .btn-apply-one {
    background: none;
    border: 1px solid #9ece6a;
    color: #9ece6a;
    padding: 2px 8px;
    font-family: inherit;
    font-size: 10px;
    cursor: pointer;
    border-radius: 2px;
  }
  
  .btn-apply-one:hover {
    background: #9ece6a;
    color: #1a1b26;
  }
  
  .error-msg {
    color: #f7768e;
    background: rgba(247, 118, 142, 0.1);
    padding: 10px;
    border-radius: 4px;
    margin-top: 12px;
  }
  
  /* Calibration Modal */
  .calibration-modal {
    max-width: 800px;
  }
  
  .calibration-instructions {
    background: var(--bg-secondary);
    padding: 12px 16px;
    border-radius: 6px;
    margin-bottom: 16px;
    border-left: 3px solid #7aa2f7;
  }
  
  .calibration-instructions p {
    margin: 0 0 6px 0;
    color: var(--text-secondary);
    font-size: 12px;
  }
  
  .calibration-hint {
    color: #7dcfff !important;
    font-style: italic;
  }
  
  .calibration-samples {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 12px;
    max-height: 400px;
    overflow-y: auto;
  }
  
  .calibration-card {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 12px;
  }
  
  .calibration-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    padding-bottom: 8px;
    border-bottom: 1px solid #3b4261;
  }
  
  .lot-badge {
    background: #7aa2f7;
    color: #1a1b26;
    padding: 2px 8px;
    border-radius: 3px;
    font-weight: bold;
    font-size: 11px;
  }
  
  .corrected-badge {
    color: #9ece6a;
    font-size: 10px;
  }
  
  .calibration-fields {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  
  .calibration-field {
    display: flex;
    flex-direction: column;
    gap: 3px;
    cursor: pointer;
  }
  
  .field-label {
    font-size: 10px;
    color: var(--text-muted);
    text-transform: uppercase;
  }
  
  .field-row {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  
  .ai-value {
    background: var(--bg-secondary);
    padding: 4px 8px;
    border-radius: 3px;
    font-size: 11px;
    color: var(--text-secondary);
    min-width: 60px;
    text-align: center;
  }
  
  .ai-value.changed {
    color: #f7768e;
    text-decoration: line-through;
  }
  
  .field-row .arrow {
    color: var(--text-muted);
    font-size: 10px;
  }
  
  .calibration-input {
    flex: 1;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    color: var(--text-primary);
    padding: 4px 8px;
    border-radius: 3px;
    font-size: 11px;
    font-family: inherit;
  }
  
  .calibration-input:focus {
    border-color: #7aa2f7;
    outline: none;
  }
  
  .btn-skip {
    background: none;
    border: 1px solid #565f89;
    color: var(--text-muted);
    padding: 6px 12px;
    font-family: inherit;
    font-size: 11px;
    cursor: pointer;
    border-radius: 3px;
  }
  
  .btn-skip:hover {
    border-color: var(--text-secondary);
    color: var(--text-secondary);
  }
  
  /* Visual Box Calibration Modal */
  .box-calibration-modal {
    max-width: 95vw;
    width: 1200px;
    max-height: 90vh;
  }
  
  .box-calibration-body {
    display: flex;
    gap: 16px;
    min-height: 500px;
  }
  
  .box-calibration-sidebar {
    width: 250px;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  
  .current-step-info {
    background: var(--bg-secondary);
    padding: 12px;
    border-radius: 6px;
    text-align: center;
  }
  
  .step-badge {
    font-size: 10px;
    color: var(--text-muted);
    margin-bottom: 4px;
  }
  
  .lot-number-display {
    font-size: 18px;
    font-weight: bold;
    color: #7aa2f7;
  }
  
  .field-badge {
    display: inline-block;
    margin-top: 8px;
    background: #bb9af7;
    color: #1a1b26;
    padding: 4px 12px;
    border-radius: 4px;
    font-weight: bold;
    font-size: 12px;
  }
  
  .ai-says {
    background: var(--bg-primary);
    padding: 10px;
    border-radius: 4px;
    border-left: 3px solid #f7768e;
  }
  
  .ai-label {
    display: block;
    font-size: 10px;
    color: var(--text-muted);
    margin-bottom: 4px;
  }
  
  .ai-extracted-value {
    font-size: 16px;
    color: #f7768e;
    font-weight: bold;
  }
  
  .user-correction-field {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
  
  .calibration-input.large {
    padding: 8px 12px;
    font-size: 14px;
  }
  
  
  .step-progress {
    padding: 8px 0;
  }
  
  .progress-dots {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    justify-content: center;
  }
  
  .progress-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #3b4261;
  }
  
  .progress-dot.active {
    background: #7aa2f7;
    box-shadow: 0 0 6px #7aa2f7;
  }
  
  .progress-dot.completed {
    background: #9ece6a;
  }
  
  .progress-dot.has-box {
    border: 2px solid #bb9af7;
  }
  
  .step-nav-buttons {
    display: flex;
    gap: 8px;
  }
  
  .btn-nav {
    flex: 1;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    color: var(--text-secondary);
    padding: 8px;
    font-family: inherit;
    font-size: 11px;
    cursor: pointer;
    border-radius: 4px;
  }
  
  .btn-nav:hover:not(:disabled) {
    background: #3b4261;
  }
  
  .btn-nav:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .btn-confirm-field {
    flex: 1;
    background: #2d4f2d;
    border: 1px solid #9ece6a;
    color: #9ece6a;
    padding: 8px;
    font-family: inherit;
    font-size: 11px;
    cursor: pointer;
    border-radius: 4px;
  }
  
  .btn-confirm-field:hover {
    background: #9ece6a;
    color: #1a1b26;
  }
  
  .box-calibration-canvas-container {
    flex: 1;
    background: var(--bg-primary);
    border-radius: 6px;
    overflow: auto;
    display: flex;
    align-items: flex-start;
    justify-content: center;
  }
  
  .box-calibration-canvas {
    max-width: 100%;
    cursor: crosshair;
  }
  
  .btn-box-calibrate {
    background: #3d2d4f;
    border: 1px solid #bb9af7;
    color: #bb9af7;
    padding: 3px 10px;
    font-family: inherit;
    font-size: 11px;
    cursor: pointer;
    border-radius: 3px;
  }
  
  .btn-box-calibrate:hover:not(:disabled) {
    background: #bb9af7;
    color: #1a1b26;
  }
  
  .btn-box-calibrate:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  

  .date-input {
    background: var(--bg-primary);
    border: 1px solid var(--accent-primary);
    border-radius: 4px;
    color: var(--text-secondary);
    padding: 4px 8px;
    font-family: inherit;
  }

  .date-value.registration {
    color: #ff9e64;
    font-weight: 500;
  }

  .date-value.settlement {
    color: #7dcfff;
    font-weight: 500;
  }

  /* ===== RESPONSIVE DESIGN ===== */
  
  /* Large tablets and small desktops */
  @media (max-width: 1200px) {
    .main {
      grid-template-columns: 220px 1fr;
    }
    
    .tree-panel {
      min-width: 220px;
    }
    
    th, td {
      padding: 6px 8px;
      font-size: 11px;
    }
  }
  
  /* Tablets */
  @media (max-width: 992px) {
    .main {
      grid-template-columns: 180px 1fr;
    }
    
    .tree-panel {
      min-width: 180px;
    }
    
    .table-content {
      max-height: calc(100vh - 240px);
    }
    
    .properties-grid {
      grid-template-columns: 1fr;
    }
    
    .panel-header {
      padding: 6px 10px;
      font-size: 11px;
    }
    
    .btn-edit, .btn-save, .btn-cancel, .btn-delete {
      padding: 3px 8px;
      font-size: 10px;
    }
  }
  
  /* Small tablets and large phones */
  @media (max-width: 768px) {
    .main {
      flex-direction: column;
    }
    
    .tree-toggle-btn {
      display: inline-flex;
      background: none;
      border: none;
      color: #7aa2f7;
      cursor: pointer;
      padding: 2px 6px;
      font-size: 12px;
    }
    
    .tree-panel {
      width: 100%;
      max-height: none;
      border-right: none;
      border-bottom: 1px solid #3b4261;
      flex-shrink: 0;
    }
    
    .tree-panel.collapsed {
      max-height: none;
    }
    
    .tree-panel.collapsed .tree-content {
      display: none;
    }
    
    .tree-content {
      max-height: 150px;
      overflow-y: auto;
    }
    
    .tree-content.hidden {
      display: none;
    }
    
    .table-panel {
      flex: 1;
      min-height: 0;
    }
    
    .hierarchy-path {
      position: sticky;
      top: 0;
      z-index: 10;
      background: var(--bg-primary);
      flex-wrap: nowrap;
      overflow-x: auto;
      scrollbar-width: none;
      border-bottom: 1px solid #3b4261;
    }
    
    .hierarchy-path::-webkit-scrollbar {
      display: none;
    }
    
    .table-content {
      max-height: calc(100vh - 280px);
      min-height: 200px;
      flex: 1;
      position: sticky;
      top: 0;
    }
    
    .table-scroll-wrapper {
      overflow: auto;
      flex: 1;
      min-height: 0;
    }
    
    thead {
      position: sticky;
      top: 0;
      z-index: 3;
      background: var(--bg-primary);
    }
    
    th {
      position: sticky;
      top: 0;
      background: var(--bg-primary);
      z-index: 2;
    }
    
    .stage-tabs {
      overflow-x: auto;
      scrollbar-width: none;
    }
    
    .stage-tabs::-webkit-scrollbar {
      display: none;
    }
    
    /* Forecast Tool - compact text stats */
    .forecast-stats-text {
      font-size: 10px;
      gap: 4px;
    }
    
    .forecast-stats-text .stat-link {
      padding: 1px 4px;
    }
    
    /* Forecast legend - inline compact */
    .forecast-legend {
      flex-wrap: wrap;
      gap: 6px;
      padding: 6px 8px;
      font-size: 9px;
    }
    
    .legend-item {
      gap: 2px;
    }
    
    .legend-color {
      width: 10px;
      height: 10px;
      font-size: 7px;
    }
    
    /* Forecast controls compact */
    .forecast-controls {
      flex-wrap: wrap;
      gap: 8px;
      padding: 8px;
    }
    
    .period-buttons {
      gap: 2px;
    }
    
    .period-btn, .period-buttons button {
      padding: 4px 8px;
      font-size: 10px;
    }
  }
  
  /* Phones */
  @media (max-width: 480px) {
    /* Prevent zoom on input focus - iOS requires 16px minimum */
    input[type="text"],
    input[type="number"],
    input[type="email"],
    input[type="password"],
    input[type="date"],
    select,
    textarea {
      font-size: 16px !important;
    }
    
    /* Fix header scroll/accessibility issues */
    .top-bar {
      position: sticky;
      top: 0;
      z-index: 100;
      padding: 8px 12px;
      flex-wrap: wrap;
      gap: 8px;
    }
    
    .app-title {
      font-size: 14px;
    }
    
    .tree-panel {
      max-height: 150px;
    }
    
    .tree-content {
      max-height: 100px;
    }
    
    .table-content {
      max-height: calc(100vh - 280px);
      min-height: 150px;
      padding: 4px;
    }
    
    th, td {
      padding: 4px 6px;
      font-size: 10px;
    }
    
    .th-actions, .actions-col {
      min-width: 80px;
    }
    
    .btn-edit, .btn-delete {
      padding: 2px 6px;
      font-size: 9px;
    }
    
    .panel-header {
      padding: 4px 8px;
      font-size: 10px;
    }
    
    .properties-grid {
      gap: 4px;
    }
    
    .property-row {
      flex-direction: column;
      align-items: flex-start;
      gap: 2px;
    }
    
    .log-panel {
      height: 60px;
      font-size: 9px;
    }
  }
  
  /* Handle very small screens */
  @media (max-width: 360px) {
    .main {
      min-width: 320px;
    }
    
    .table-scroll-wrapper {
      min-width: 300px;
    }
  }
  
  /* Landscape phone orientation */
  @media (max-height: 500px) and (orientation: landscape) {
    .tree-panel {
      max-height: 120px;
    }
    
    .table-content {
      max-height: calc(100vh - 180px);
      min-height: 120px;
    }
    
    .log-panel {
      height: 40px;
    }
  }
</style>
